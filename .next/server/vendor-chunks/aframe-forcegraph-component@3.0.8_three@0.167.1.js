/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/aframe-forcegraph-component@3.0.8_three@0.167.1";
exports.ids = ["vendor-chunks/aframe-forcegraph-component@3.0.8_three@0.167.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.167.1/node_modules/aframe-forcegraph-component/index.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.167.1/node_modules/aframe-forcegraph-component/index.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* global AFRAME */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nlet accessorFn = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/.pnpm/accessor-fn@1.5.1/node_modules/accessor-fn/dist/accessor-fn.mjs\");\nif ('default' in accessorFn) {\n  // unwrap default export\n  accessorFn = accessorFn.default;\n}\n\nlet ThreeForceGraph = __webpack_require__(/*! three-forcegraph */ \"(ssr)/./node_modules/.pnpm/three-forcegraph@1.41.14_three@0.167.1/node_modules/three-forcegraph/dist/three-forcegraph.mjs\");\nif ('default' in ThreeForceGraph) {\n  // unwrap default export\n  ThreeForceGraph = ThreeForceGraph.default;\n}\n\nconst parseJson = function (prop) {\n  return (typeof prop === 'string')\n    ? JSON.parse(prop)\n    : prop; // already parsed\n};\n\nconst parseFn = function (prop) {\n  if (typeof prop === 'function') return prop; // already a function\n  const geval = eval; // Avoid using eval directly https://github.com/rollup/rollup/wiki/Troubleshooting#avoiding-eval\n  try {\n    const evalled = geval('(' + prop + ')');\n    return evalled;\n  } catch (e) {} // Can't eval, not a function\n  return null;\n};\n\nconst parseAccessor = function (prop) {\n  if (!isNaN(parseFloat(prop))) { return parseFloat(prop); } // parse numbers\n  if (parseFn(prop)) { return parseFn(prop); } // parse functions\n  return prop; // strings\n};\n\n/**\n * 3D Force-Directed Graph component for A-Frame.\n */\nAFRAME.registerComponent('forcegraph', {\n  schema: {\n    jsonUrl: { type: 'string', default: '' },\n    nodes: { parse: parseJson, default: [] },\n    links: { parse: parseJson, default: [] },\n    numDimensions: { type: 'number', default: 3 },\n    dagMode: { type: 'string', default: '' },\n    dagLevelDistance: { type: 'number', default: 0 },\n    dagNodeFilter: { parse: parseFn, default: function() { return true; }},\n    onDagError: { parse: parseFn, default: undefined },\n    nodeRelSize: { type: 'number', default: 4 }, // volume per val unit\n    nodeId: { type: 'string', default: 'id' },\n    nodeVal: { parse: parseAccessor, default: 'val' },\n    nodeResolution: { type: 'number', default: 8 }, // how many slice segments in the sphere's circumference\n    nodeVisibility: { parse: parseAccessor, default: true },\n    nodeColor: { parse: parseAccessor, default: 'color' },\n    nodeAutoColorBy: { parse: parseAccessor, default: '' }, // color nodes with the same field equally\n    nodeOpacity: { type: 'number', default: 0.75 },\n    nodeThreeObject: { parse: parseAccessor, default: null },\n    nodeThreeObjectExtend: { parse: parseAccessor, default: false },\n    linkSource: { type: 'string', default: 'source' },\n    linkTarget: { type: 'string', default: 'target' },\n    linkVisibility: { parse: parseAccessor, default: true },\n    linkColor: { parse: parseAccessor, default: 'color' },\n    linkAutoColorBy: { parse: parseAccessor, default: '' }, // color links with the same field equally\n    linkOpacity: { type: 'number', default: 0.2 },\n    linkWidth: { parse: parseAccessor, default: 0 },\n    linkResolution: { type: 'number', default: 6 }, // how many radial segments in each line cylinder's geometry\n    linkCurvature: { parse: parseAccessor, default: 0 },\n    linkCurveRotation: { parse: parseAccessor, default: 0 },\n    linkMaterial: { parse: parseAccessor, default: null },\n    linkThreeObject: { parse: parseAccessor, default: null },\n    linkThreeObjectExtend: { parse: parseAccessor, default: false },\n    linkPositionUpdate: { parse: parseFn, default: null },\n    linkDirectionalArrowLength: { parse: parseAccessor, default: 0 },\n    linkDirectionalArrowColor: { parse: parseAccessor, default: null },\n    linkDirectionalArrowRelPos: { parse: parseAccessor, default: 0.5 }, // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: { type: 'number', default: 8 }, // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: { parse: parseAccessor, default: 0 }, // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: { parse: parseAccessor, default: 0.01 }, // in link length ratio per frame\n    linkDirectionalParticleWidth: { parse: parseAccessor, default: 0.5 },\n    linkDirectionalParticleColor: { parse: parseAccessor, default: null },\n    linkDirectionalParticleResolution: { type: 'number', default: 4 }, // how many slice segments in the particle sphere's circumference\n    onNodeHover: { parse: parseFn, default: () => {} },\n    onLinkHover: { parse: parseFn, default: () => {} },\n    onNodeClick: { parse: parseFn, default: () => {} },\n    onLinkClick: { parse: parseFn, default: () => {} },\n    forceEngine: { type: 'string', default: 'd3' }, // 'd3' or 'ngraph'\n    d3AlphaMin: { type: 'number', default: 0 },\n    d3AlphaDecay: { type: 'number', default: 0.0228 },\n    d3VelocityDecay: { type: 'number', default: 0.4 },\n    ngraphPhysics: { parse: parseJson, default: null },\n    warmupTicks: { type: 'int', default: 0 }, // how many times to tick the force engine at init before starting to render\n    cooldownTicks: { type: 'int', default: 1e18 }, // Simulate infinity (int parser doesn't accept Infinity object)\n    cooldownTime: { type: 'int', default: 15000 }, // ms\n    onEngineTick: { parse: parseFn, default: function () {} },\n    onEngineStop: { parse: parseFn, default: function () {} }\n  },\n\n  // Bind component methods\n  getGraphBbox: function() {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    return this.forceGraph.getGraphBbox();\n  },\n  emitParticle: function () {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    const forceGraph = this.forceGraph;\n    const returnVal = forceGraph.emitParticle.apply(forceGraph, arguments);\n\n    return returnVal === forceGraph\n      ? this // return self, not the inner forcegraph component\n      : returnVal;\n  },\n\n  d3Force: function () {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    const forceGraph = this.forceGraph;\n    const returnVal = forceGraph.d3Force.apply(forceGraph, arguments);\n\n    return returnVal === forceGraph\n      ? this // return self, not the inner forcegraph component\n      : returnVal;\n  },\n\n  d3ReheatSimulation: function () {\n    this.forceGraph && this.forceGraph.d3ReheatSimulation();\n    return this;\n  },\n\n  refresh: function () {\n    this.forceGraph && this.forceGraph.refresh();\n    return this;\n  },\n\n  init: function () {\n    const state = this.state = {}; // Internal state\n\n    // Add info msg\n    state.infoEl = document.createElement('a-text');\n    state.infoEl.setAttribute('position', '0 -0.1 -1'); // Canvas center\n    state.infoEl.setAttribute('width', 1);\n    state.infoEl.setAttribute('align', 'center');\n    state.infoEl.setAttribute('color', 'lavender');\n\n    // Get camera dom element and attach fixed view elements to camera\n    const cameraEl = document.querySelector('a-entity[camera], a-camera');\n    cameraEl.appendChild(state.infoEl);\n\n    // Keep reference to Three camera object\n    state.cameraObj = cameraEl.object3D.children\n      .filter(function (child) { return child.type === 'PerspectiveCamera'; })[0];\n\n    // On camera switch\n    this.el.sceneEl.addEventListener('camera-set-active', function (evt) {\n      // Switch camera reference\n      state.cameraObj = evt.detail.cameraEl.components.camera.camera;\n    });\n\n    // setup FG object\n    if (!this.forceGraph) this.forceGraph = new ThreeForceGraph(); // initialize forceGraph if it doesn't exist yet\n    this.forceGraph\n      .onFinishUpdate(() => this.el.setObject3D('forcegraphGroup', this.forceGraph)) // Bind forcegraph to elem\n      .onLoading(() => state.infoEl.setAttribute('value', 'Loading...')) // Add loading msg\n      .onFinishLoading(() => state.infoEl.setAttribute('value', ''));\n\n    // prefer raycaster events over mouseenter/mouseleave because they expose immediately available intersection data via detail.getIntersection()\n    this.el.addEventListener('raycaster-intersected', ev => state.hoverDetail = ev.detail);\n    this.el.addEventListener('raycaster-intersected-cleared', ev => state.hoverDetail = ev.detail);\n\n    this.el.addEventListener('click', () =>\n      state.hoverObj && this.data['on' + (state.hoverObj.__graphObjType === 'node' ? 'Node' : 'Link') + 'Click'](state.hoverObj.__data)\n    );\n  },\n\n  remove: function () {\n    // Clean-up elems\n    this.state.infoEl.remove();\n    this.el.removeObject3D('forcegraphGroup');\n  },\n\n  update: function (oldData) {\n    const comp = this;\n    const elData = this.data;\n    const diff = AFRAME.utils.diff(elData, oldData);\n\n    const fgProps = [\n      'jsonUrl',\n      'numDimensions',\n      'dagMode',\n      'dagLevelDistance',\n      'dagNodeFilter',\n      'onDagError',\n      'nodeRelSize',\n      'nodeId',\n      'nodeVal',\n      'nodeResolution',\n      'nodeVisibility',\n      'nodeColor',\n      'nodeAutoColorBy',\n      'nodeOpacity',\n      'nodeThreeObject',\n      'nodeThreeObjectExtend',\n      'linkSource',\n      'linkTarget',\n      'linkVisibility',\n      'linkColor',\n      'linkAutoColorBy',\n      'linkOpacity',\n      'linkWidth',\n      'linkResolution',\n      'linkCurvature',\n      'linkCurveRotation',\n      'linkMaterial',\n      'linkThreeObject',\n      'linkThreeObjectExtend',\n      'linkPositionUpdate',\n      'linkDirectionalArrowLength',\n      'linkDirectionalArrowColor',\n      'linkDirectionalArrowRelPos',\n      'linkDirectionalArrowResolution',\n      'linkDirectionalParticles',\n      'linkDirectionalParticleSpeed',\n      'linkDirectionalParticleWidth',\n      'linkDirectionalParticleColor',\n      'linkDirectionalParticleResolution',\n      'forceEngine',\n      'd3AlphaMin',\n      'd3AphaDecay',\n      'd3VelocityDecay',\n      'ngraphPhysics',\n      'warmupTicks',\n      'cooldownTicks',\n      'cooldownTime',\n      'onEngineTick',\n      'onEngineStop'\n    ];\n\n    fgProps\n      .filter(function (p) { return p in diff; })\n      .forEach(function (p) { comp.forceGraph[p](elData[p] !== '' ? elData[p] : null); }); // Convert blank values into nulls\n\n    if ('nodes' in diff || 'links' in diff) {\n      comp.forceGraph.graphData({\n        nodes: elData.nodes,\n        links: elData.links\n      });\n    }\n  },\n\n  tick: function (t, td) {\n    const state = this.state;\n    const props = this.data;\n\n    // Update hover (intersected) object\n    const intersection = state.hoverDetail\n      ? state.hoverDetail.getIntersection\n        ? state.hoverDetail.getIntersection(this.el) // available in raycaster-intersected events\n        : state.hoverDetail.intersection || undefined // available in mouseenter/mouseleave events (with delayed update)\n      : undefined;\n\n    // Note:\n    // Unfortunately we only have access to the intersected object closer to the camera (1st element in the raycaster intersectObjects result),\n    // there is no \".getIntersections()\" method available in the event details. Therefore, we can't prioritize hover on nodes over links, or even exclude\n    // objects that are neither nodes or links. This makes the interaction a bit erratic if nodes have a lot of links in front.\n    // Configuring the raycaster.params.Line.threshold might help with this somewhat, but that config is also not available via the a-frame raycaster component.\n\n    // recurse up until forcegraph obj is found\n    let topObject = intersection ? intersection.object : undefined;\n    while (topObject && !topObject.hasOwnProperty('__graphObjType'))\n      topObject = topObject.parent;\n\n    if (topObject !== state.hoverObj) {\n      const prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;\n      const prevObjData = state.hoverObj ? state.hoverObj.__data : null;\n      const objType = topObject ? topObject.__graphObjType : null;\n      const objData = topObject ? topObject.__data : null;\n\n      if (prevObjType && prevObjType !== objType) {\n        // Hover out\n        props['on' + (prevObjType === 'node' ? 'Node' : 'Link') + 'Hover'](null, prevObjData);\n      }\n      if (objType) {\n        // Hover in\n        props['on' + (objType === 'node' ? 'Node' : 'Link') + 'Hover'](objData, prevObjType === objType ? prevObjData : null);\n      }\n\n      state.hoverObj = topObject;\n    }\n\n    // Run force-graph ticker\n    this.forceGraph.tickFrame();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWZyYW1lLWZvcmNlZ3JhcGgtY29tcG9uZW50QDMuMC44X3RocmVlQDAuMTY3LjEvbm9kZV9tb2R1bGVzL2FmcmFtZS1mb3JjZWdyYXBoLWNvbXBvbmVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsK0dBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsbUpBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLCtDQUErQztBQUMvQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdELHVCQUF1Qix3QkFBd0I7QUFDL0MsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLCtCQUErQjtBQUM1QyxxQkFBcUIsNEJBQTRCO0FBQ2pELGVBQWUsNkJBQTZCO0FBQzVDLHdCQUF3Qiw0QkFBNEI7QUFDcEQscUJBQXFCLHNDQUFzQyxlQUFlO0FBQzFFLGtCQUFrQixvQ0FBb0M7QUFDdEQsbUJBQW1CLDRCQUE0QjtBQUMvQyxjQUFjLCtCQUErQjtBQUM3QyxlQUFlLHNDQUFzQztBQUNyRCxzQkFBc0IsNEJBQTRCO0FBQ2xELHNCQUFzQixxQ0FBcUM7QUFDM0QsaUJBQWlCLHdDQUF3QztBQUN6RCx1QkFBdUIsbUNBQW1DO0FBQzFELG1CQUFtQiwrQkFBK0I7QUFDbEQsdUJBQXVCLHFDQUFxQztBQUM1RCw2QkFBNkIsc0NBQXNDO0FBQ25FLGtCQUFrQixtQ0FBbUM7QUFDckQsa0JBQWtCLG1DQUFtQztBQUNyRCxzQkFBc0IscUNBQXFDO0FBQzNELGlCQUFpQix3Q0FBd0M7QUFDekQsdUJBQXVCLG1DQUFtQztBQUMxRCxtQkFBbUIsOEJBQThCO0FBQ2pELGlCQUFpQixrQ0FBa0M7QUFDbkQsc0JBQXNCLDRCQUE0QjtBQUNsRCxxQkFBcUIsa0NBQWtDO0FBQ3ZELHlCQUF5QixrQ0FBa0M7QUFDM0Qsb0JBQW9CLHFDQUFxQztBQUN6RCx1QkFBdUIscUNBQXFDO0FBQzVELDZCQUE2QixzQ0FBc0M7QUFDbkUsMEJBQTBCLCtCQUErQjtBQUN6RCxrQ0FBa0Msa0NBQWtDO0FBQ3BFLGlDQUFpQyxxQ0FBcUM7QUFDdEUsa0NBQWtDLG9DQUFvQztBQUN0RSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLGdDQUFnQyxrQ0FBa0M7QUFDbEUsb0NBQW9DLHFDQUFxQztBQUN6RSxvQ0FBb0Msb0NBQW9DO0FBQ3hFLG9DQUFvQyxxQ0FBcUM7QUFDekUseUNBQXlDLDRCQUE0QjtBQUNyRSxtQkFBbUIsbUNBQW1DO0FBQ3RELG1CQUFtQixtQ0FBbUM7QUFDdEQsbUJBQW1CLG1DQUFtQztBQUN0RCxtQkFBbUIsbUNBQW1DO0FBQ3RELG1CQUFtQiwrQkFBK0I7QUFDbEQsa0JBQWtCLDRCQUE0QjtBQUM5QyxvQkFBb0IsaUNBQWlDO0FBQ3JELHVCQUF1Qiw4QkFBOEI7QUFDckQscUJBQXFCLGlDQUFpQztBQUN0RCxtQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFxQiw0QkFBNEI7QUFDakQsb0JBQW9CLDZCQUE2QjtBQUNqRCxvQkFBb0IseUNBQXlDO0FBQzdELG9CQUFvQjtBQUNwQixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0Qzs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hELDhCQUE4QiwwREFBMEQsR0FBRzs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hX3Bvc3Rfc2NhcmNpdHkvLi9ub2RlX21vZHVsZXMvLnBucG0vYWZyYW1lLWZvcmNlZ3JhcGgtY29tcG9uZW50QDMuMC44X3RocmVlQDAuMTY3LjEvbm9kZV9tb2R1bGVzL2FmcmFtZS1mb3JjZWdyYXBoLWNvbXBvbmVudC9pbmRleC5qcz9iMDY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBBRlJBTUUgKi9cblxuaWYgKHR5cGVvZiBBRlJBTUUgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGF0dGVtcHRlZCB0byByZWdpc3RlciBiZWZvcmUgQUZSQU1FIHdhcyBhdmFpbGFibGUuJyk7XG59XG5cbmxldCBhY2Nlc3NvckZuID0gcmVxdWlyZSgnYWNjZXNzb3ItZm4nKTtcbmlmICgnZGVmYXVsdCcgaW4gYWNjZXNzb3JGbikge1xuICAvLyB1bndyYXAgZGVmYXVsdCBleHBvcnRcbiAgYWNjZXNzb3JGbiA9IGFjY2Vzc29yRm4uZGVmYXVsdDtcbn1cblxubGV0IFRocmVlRm9yY2VHcmFwaCA9IHJlcXVpcmUoJ3RocmVlLWZvcmNlZ3JhcGgnKTtcbmlmICgnZGVmYXVsdCcgaW4gVGhyZWVGb3JjZUdyYXBoKSB7XG4gIC8vIHVud3JhcCBkZWZhdWx0IGV4cG9ydFxuICBUaHJlZUZvcmNlR3JhcGggPSBUaHJlZUZvcmNlR3JhcGguZGVmYXVsdDtcbn1cblxuY29uc3QgcGFyc2VKc29uID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpXG4gICAgPyBKU09OLnBhcnNlKHByb3ApXG4gICAgOiBwcm9wOyAvLyBhbHJlYWR5IHBhcnNlZFxufTtcblxuY29uc3QgcGFyc2VGbiA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHByb3A7IC8vIGFscmVhZHkgYSBmdW5jdGlvblxuICBjb25zdCBnZXZhbCA9IGV2YWw7IC8vIEF2b2lkIHVzaW5nIGV2YWwgZGlyZWN0bHkgaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvd2lraS9Ucm91Ymxlc2hvb3RpbmcjYXZvaWRpbmctZXZhbFxuICB0cnkge1xuICAgIGNvbnN0IGV2YWxsZWQgPSBnZXZhbCgnKCcgKyBwcm9wICsgJyknKTtcbiAgICByZXR1cm4gZXZhbGxlZDtcbiAgfSBjYXRjaCAoZSkge30gLy8gQ2FuJ3QgZXZhbCwgbm90IGEgZnVuY3Rpb25cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBwYXJzZUFjY2Vzc29yID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHByb3ApKSkgeyByZXR1cm4gcGFyc2VGbG9hdChwcm9wKTsgfSAvLyBwYXJzZSBudW1iZXJzXG4gIGlmIChwYXJzZUZuKHByb3ApKSB7IHJldHVybiBwYXJzZUZuKHByb3ApOyB9IC8vIHBhcnNlIGZ1bmN0aW9uc1xuICByZXR1cm4gcHJvcDsgLy8gc3RyaW5nc1xufTtcblxuLyoqXG4gKiAzRCBGb3JjZS1EaXJlY3RlZCBHcmFwaCBjb21wb25lbnQgZm9yIEEtRnJhbWUuXG4gKi9cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnZm9yY2VncmFwaCcsIHtcbiAgc2NoZW1hOiB7XG4gICAganNvblVybDogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJycgfSxcbiAgICBub2RlczogeyBwYXJzZTogcGFyc2VKc29uLCBkZWZhdWx0OiBbXSB9LFxuICAgIGxpbmtzOiB7IHBhcnNlOiBwYXJzZUpzb24sIGRlZmF1bHQ6IFtdIH0sXG4gICAgbnVtRGltZW5zaW9uczogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMyB9LFxuICAgIGRhZ01vZGU6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgZGFnTGV2ZWxEaXN0YW5jZTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LFxuICAgIGRhZ05vZGVGaWx0ZXI6IHsgcGFyc2U6IHBhcnNlRm4sIGRlZmF1bHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfX0sXG4gICAgb25EYWdFcnJvcjogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXG4gICAgbm9kZVJlbFNpemU6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDQgfSwgLy8gdm9sdW1lIHBlciB2YWwgdW5pdFxuICAgIG5vZGVJZDogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJ2lkJyB9LFxuICAgIG5vZGVWYWw6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6ICd2YWwnIH0sXG4gICAgbm9kZVJlc29sdXRpb246IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDggfSwgLy8gaG93IG1hbnkgc2xpY2Ugc2VnbWVudHMgaW4gdGhlIHNwaGVyZSdzIGNpcmN1bWZlcmVuY2VcbiAgICBub2RlVmlzaWJpbGl0eTogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogdHJ1ZSB9LFxuICAgIG5vZGVDb2xvcjogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogJ2NvbG9yJyB9LFxuICAgIG5vZGVBdXRvQ29sb3JCeTogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogJycgfSwgLy8gY29sb3Igbm9kZXMgd2l0aCB0aGUgc2FtZSBmaWVsZCBlcXVhbGx5XG4gICAgbm9kZU9wYWNpdHk6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDAuNzUgfSxcbiAgICBub2RlVGhyZWVPYmplY3Q6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IG51bGwgfSxcbiAgICBub2RlVGhyZWVPYmplY3RFeHRlbmQ6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgbGlua1NvdXJjZTogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJ3NvdXJjZScgfSxcbiAgICBsaW5rVGFyZ2V0OiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAndGFyZ2V0JyB9LFxuICAgIGxpbmtWaXNpYmlsaXR5OiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgbGlua0NvbG9yOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAnY29sb3InIH0sXG4gICAgbGlua0F1dG9Db2xvckJ5OiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAnJyB9LCAvLyBjb2xvciBsaW5rcyB3aXRoIHRoZSBzYW1lIGZpZWxkIGVxdWFsbHlcbiAgICBsaW5rT3BhY2l0eTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMC4yIH0sXG4gICAgbGlua1dpZHRoOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwIH0sXG4gICAgbGlua1Jlc29sdXRpb246IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDYgfSwgLy8gaG93IG1hbnkgcmFkaWFsIHNlZ21lbnRzIGluIGVhY2ggbGluZSBjeWxpbmRlcidzIGdlb21ldHJ5XG4gICAgbGlua0N1cnZhdHVyZTogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogMCB9LFxuICAgIGxpbmtDdXJ2ZVJvdGF0aW9uOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwIH0sXG4gICAgbGlua01hdGVyaWFsOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgbGlua1RocmVlT2JqZWN0OiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgbGlua1RocmVlT2JqZWN0RXh0ZW5kOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGxpbmtQb3NpdGlvblVwZGF0ZTogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogbnVsbCB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcjogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogbnVsbCB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93UmVsUG9zOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwLjUgfSwgLy8gdmFsdWUgYmV0d2VlbiAwPD4xIGluZGljYXRpbmcgdGhlIHJlbGF0aXZlIHBvcyBhbG9uZyB0aGUgKGV4cG9zZWQpIGxpbmVcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd1Jlc29sdXRpb246IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDggfSwgLy8gaG93IG1hbnkgc2xpY2Ugc2VnbWVudHMgaW4gdGhlIGFycm93J3MgY29uaWMgY2lyY3VtZmVyZW5jZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlczogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogMCB9LCAvLyBhbmltYXRlIHBob3RvbnMgdHJhdmVsbGluZyBpbiB0aGUgbGluayBkaXJlY3Rpb25cbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwLjAxIH0sIC8vIGluIGxpbmsgbGVuZ3RoIHJhdGlvIHBlciBmcmFtZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGg6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IDAuNSB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3I6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IG51bGwgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb246IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDQgfSwgLy8gaG93IG1hbnkgc2xpY2Ugc2VnbWVudHMgaW4gdGhlIHBhcnRpY2xlIHNwaGVyZSdzIGNpcmN1bWZlcmVuY2VcbiAgICBvbk5vZGVIb3ZlcjogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogKCkgPT4ge30gfSxcbiAgICBvbkxpbmtIb3ZlcjogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogKCkgPT4ge30gfSxcbiAgICBvbk5vZGVDbGljazogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogKCkgPT4ge30gfSxcbiAgICBvbkxpbmtDbGljazogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogKCkgPT4ge30gfSxcbiAgICBmb3JjZUVuZ2luZTogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJ2QzJyB9LCAvLyAnZDMnIG9yICduZ3JhcGgnXG4gICAgZDNBbHBoYU1pbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LFxuICAgIGQzQWxwaGFEZWNheTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMC4wMjI4IH0sXG4gICAgZDNWZWxvY2l0eURlY2F5OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwLjQgfSxcbiAgICBuZ3JhcGhQaHlzaWNzOiB7IHBhcnNlOiBwYXJzZUpzb24sIGRlZmF1bHQ6IG51bGwgfSxcbiAgICB3YXJtdXBUaWNrczogeyB0eXBlOiAnaW50JywgZGVmYXVsdDogMCB9LCAvLyBob3cgbWFueSB0aW1lcyB0byB0aWNrIHRoZSBmb3JjZSBlbmdpbmUgYXQgaW5pdCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVuZGVyXG4gICAgY29vbGRvd25UaWNrczogeyB0eXBlOiAnaW50JywgZGVmYXVsdDogMWUxOCB9LCAvLyBTaW11bGF0ZSBpbmZpbml0eSAoaW50IHBhcnNlciBkb2Vzbid0IGFjY2VwdCBJbmZpbml0eSBvYmplY3QpXG4gICAgY29vbGRvd25UaW1lOiB7IHR5cGU6ICdpbnQnLCBkZWZhdWx0OiAxNTAwMCB9LCAvLyBtc1xuICAgIG9uRW5naW5lVGljazogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogZnVuY3Rpb24gKCkge30gfSxcbiAgICBvbkVuZ2luZVN0b3A6IHsgcGFyc2U6IHBhcnNlRm4sIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHt9IH1cbiAgfSxcblxuICAvLyBCaW5kIGNvbXBvbmVudCBtZXRob2RzXG4gIGdldEdyYXBoQmJveDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmZvcmNlR3JhcGgpIHtcbiAgICAgIC8vIEdvdCBoZXJlIGJlZm9yZSBjb21wb25lbnQgaW5pdCAtPiBpbml0aWFsaXplIGZvcmNlR3JhcGhcbiAgICAgIHRoaXMuZm9yY2VHcmFwaCA9IG5ldyBUaHJlZUZvcmNlR3JhcGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mb3JjZUdyYXBoLmdldEdyYXBoQmJveCgpO1xuICB9LFxuICBlbWl0UGFydGljbGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZm9yY2VHcmFwaCkge1xuICAgICAgLy8gR290IGhlcmUgYmVmb3JlIGNvbXBvbmVudCBpbml0IC0+IGluaXRpYWxpemUgZm9yY2VHcmFwaFxuICAgICAgdGhpcy5mb3JjZUdyYXBoID0gbmV3IFRocmVlRm9yY2VHcmFwaCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcmNlR3JhcGggPSB0aGlzLmZvcmNlR3JhcGg7XG4gICAgY29uc3QgcmV0dXJuVmFsID0gZm9yY2VHcmFwaC5lbWl0UGFydGljbGUuYXBwbHkoZm9yY2VHcmFwaCwgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiByZXR1cm5WYWwgPT09IGZvcmNlR3JhcGhcbiAgICAgID8gdGhpcyAvLyByZXR1cm4gc2VsZiwgbm90IHRoZSBpbm5lciBmb3JjZWdyYXBoIGNvbXBvbmVudFxuICAgICAgOiByZXR1cm5WYWw7XG4gIH0sXG5cbiAgZDNGb3JjZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5mb3JjZUdyYXBoKSB7XG4gICAgICAvLyBHb3QgaGVyZSBiZWZvcmUgY29tcG9uZW50IGluaXQgLT4gaW5pdGlhbGl6ZSBmb3JjZUdyYXBoXG4gICAgICB0aGlzLmZvcmNlR3JhcGggPSBuZXcgVGhyZWVGb3JjZUdyYXBoKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9yY2VHcmFwaCA9IHRoaXMuZm9yY2VHcmFwaDtcbiAgICBjb25zdCByZXR1cm5WYWwgPSBmb3JjZUdyYXBoLmQzRm9yY2UuYXBwbHkoZm9yY2VHcmFwaCwgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiByZXR1cm5WYWwgPT09IGZvcmNlR3JhcGhcbiAgICAgID8gdGhpcyAvLyByZXR1cm4gc2VsZiwgbm90IHRoZSBpbm5lciBmb3JjZWdyYXBoIGNvbXBvbmVudFxuICAgICAgOiByZXR1cm5WYWw7XG4gIH0sXG5cbiAgZDNSZWhlYXRTaW11bGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JjZUdyYXBoICYmIHRoaXMuZm9yY2VHcmFwaC5kM1JlaGVhdFNpbXVsYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JjZUdyYXBoICYmIHRoaXMuZm9yY2VHcmFwaC5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSA9IHt9OyAvLyBJbnRlcm5hbCBzdGF0ZVxuXG4gICAgLy8gQWRkIGluZm8gbXNnXG4gICAgc3RhdGUuaW5mb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS10ZXh0Jyk7XG4gICAgc3RhdGUuaW5mb0VsLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCAnMCAtMC4xIC0xJyk7IC8vIENhbnZhcyBjZW50ZXJcbiAgICBzdGF0ZS5pbmZvRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDEpO1xuICAgIHN0YXRlLmluZm9FbC5zZXRBdHRyaWJ1dGUoJ2FsaWduJywgJ2NlbnRlcicpO1xuICAgIHN0YXRlLmluZm9FbC5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgJ2xhdmVuZGVyJyk7XG5cbiAgICAvLyBHZXQgY2FtZXJhIGRvbSBlbGVtZW50IGFuZCBhdHRhY2ggZml4ZWQgdmlldyBlbGVtZW50cyB0byBjYW1lcmFcbiAgICBjb25zdCBjYW1lcmFFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2EtZW50aXR5W2NhbWVyYV0sIGEtY2FtZXJhJyk7XG4gICAgY2FtZXJhRWwuYXBwZW5kQ2hpbGQoc3RhdGUuaW5mb0VsKTtcblxuICAgIC8vIEtlZXAgcmVmZXJlbmNlIHRvIFRocmVlIGNhbWVyYSBvYmplY3RcbiAgICBzdGF0ZS5jYW1lcmFPYmogPSBjYW1lcmFFbC5vYmplY3QzRC5jaGlsZHJlblxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnR5cGUgPT09ICdQZXJzcGVjdGl2ZUNhbWVyYSc7IH0pWzBdO1xuXG4gICAgLy8gT24gY2FtZXJhIHN3aXRjaFxuICAgIHRoaXMuZWwuc2NlbmVFbC5hZGRFdmVudExpc3RlbmVyKCdjYW1lcmEtc2V0LWFjdGl2ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIC8vIFN3aXRjaCBjYW1lcmEgcmVmZXJlbmNlXG4gICAgICBzdGF0ZS5jYW1lcmFPYmogPSBldnQuZGV0YWlsLmNhbWVyYUVsLmNvbXBvbmVudHMuY2FtZXJhLmNhbWVyYTtcbiAgICB9KTtcblxuICAgIC8vIHNldHVwIEZHIG9iamVjdFxuICAgIGlmICghdGhpcy5mb3JjZUdyYXBoKSB0aGlzLmZvcmNlR3JhcGggPSBuZXcgVGhyZWVGb3JjZUdyYXBoKCk7IC8vIGluaXRpYWxpemUgZm9yY2VHcmFwaCBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgIHRoaXMuZm9yY2VHcmFwaFxuICAgICAgLm9uRmluaXNoVXBkYXRlKCgpID0+IHRoaXMuZWwuc2V0T2JqZWN0M0QoJ2ZvcmNlZ3JhcGhHcm91cCcsIHRoaXMuZm9yY2VHcmFwaCkpIC8vIEJpbmQgZm9yY2VncmFwaCB0byBlbGVtXG4gICAgICAub25Mb2FkaW5nKCgpID0+IHN0YXRlLmluZm9FbC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJ0xvYWRpbmcuLi4nKSkgLy8gQWRkIGxvYWRpbmcgbXNnXG4gICAgICAub25GaW5pc2hMb2FkaW5nKCgpID0+IHN0YXRlLmluZm9FbC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycpKTtcblxuICAgIC8vIHByZWZlciByYXljYXN0ZXIgZXZlbnRzIG92ZXIgbW91c2VlbnRlci9tb3VzZWxlYXZlIGJlY2F1c2UgdGhleSBleHBvc2UgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGludGVyc2VjdGlvbiBkYXRhIHZpYSBkZXRhaWwuZ2V0SW50ZXJzZWN0aW9uKClcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3JheWNhc3Rlci1pbnRlcnNlY3RlZCcsIGV2ID0+IHN0YXRlLmhvdmVyRGV0YWlsID0gZXYuZGV0YWlsKTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3JheWNhc3Rlci1pbnRlcnNlY3RlZC1jbGVhcmVkJywgZXYgPT4gc3RhdGUuaG92ZXJEZXRhaWwgPSBldi5kZXRhaWwpO1xuXG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+XG4gICAgICBzdGF0ZS5ob3Zlck9iaiAmJiB0aGlzLmRhdGFbJ29uJyArIChzdGF0ZS5ob3Zlck9iai5fX2dyYXBoT2JqVHlwZSA9PT0gJ25vZGUnID8gJ05vZGUnIDogJ0xpbmsnKSArICdDbGljayddKHN0YXRlLmhvdmVyT2JqLl9fZGF0YSlcbiAgICApO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsZWFuLXVwIGVsZW1zXG4gICAgdGhpcy5zdGF0ZS5pbmZvRWwucmVtb3ZlKCk7XG4gICAgdGhpcy5lbC5yZW1vdmVPYmplY3QzRCgnZm9yY2VncmFwaEdyb3VwJyk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIGNvbnN0IGNvbXAgPSB0aGlzO1xuICAgIGNvbnN0IGVsRGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBkaWZmID0gQUZSQU1FLnV0aWxzLmRpZmYoZWxEYXRhLCBvbGREYXRhKTtcblxuICAgIGNvbnN0IGZnUHJvcHMgPSBbXG4gICAgICAnanNvblVybCcsXG4gICAgICAnbnVtRGltZW5zaW9ucycsXG4gICAgICAnZGFnTW9kZScsXG4gICAgICAnZGFnTGV2ZWxEaXN0YW5jZScsXG4gICAgICAnZGFnTm9kZUZpbHRlcicsXG4gICAgICAnb25EYWdFcnJvcicsXG4gICAgICAnbm9kZVJlbFNpemUnLFxuICAgICAgJ25vZGVJZCcsXG4gICAgICAnbm9kZVZhbCcsXG4gICAgICAnbm9kZVJlc29sdXRpb24nLFxuICAgICAgJ25vZGVWaXNpYmlsaXR5JyxcbiAgICAgICdub2RlQ29sb3InLFxuICAgICAgJ25vZGVBdXRvQ29sb3JCeScsXG4gICAgICAnbm9kZU9wYWNpdHknLFxuICAgICAgJ25vZGVUaHJlZU9iamVjdCcsXG4gICAgICAnbm9kZVRocmVlT2JqZWN0RXh0ZW5kJyxcbiAgICAgICdsaW5rU291cmNlJyxcbiAgICAgICdsaW5rVGFyZ2V0JyxcbiAgICAgICdsaW5rVmlzaWJpbGl0eScsXG4gICAgICAnbGlua0NvbG9yJyxcbiAgICAgICdsaW5rQXV0b0NvbG9yQnknLFxuICAgICAgJ2xpbmtPcGFjaXR5JyxcbiAgICAgICdsaW5rV2lkdGgnLFxuICAgICAgJ2xpbmtSZXNvbHV0aW9uJyxcbiAgICAgICdsaW5rQ3VydmF0dXJlJyxcbiAgICAgICdsaW5rQ3VydmVSb3RhdGlvbicsXG4gICAgICAnbGlua01hdGVyaWFsJyxcbiAgICAgICdsaW5rVGhyZWVPYmplY3QnLFxuICAgICAgJ2xpbmtUaHJlZU9iamVjdEV4dGVuZCcsXG4gICAgICAnbGlua1Bvc2l0aW9uVXBkYXRlJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCcsXG4gICAgICAnbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcicsXG4gICAgICAnbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3MnLFxuICAgICAgJ2xpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbicsXG4gICAgICAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVzJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb24nLFxuICAgICAgJ2ZvcmNlRW5naW5lJyxcbiAgICAgICdkM0FscGhhTWluJyxcbiAgICAgICdkM0FwaGFEZWNheScsXG4gICAgICAnZDNWZWxvY2l0eURlY2F5JyxcbiAgICAgICduZ3JhcGhQaHlzaWNzJyxcbiAgICAgICd3YXJtdXBUaWNrcycsXG4gICAgICAnY29vbGRvd25UaWNrcycsXG4gICAgICAnY29vbGRvd25UaW1lJyxcbiAgICAgICdvbkVuZ2luZVRpY2snLFxuICAgICAgJ29uRW5naW5lU3RvcCdcbiAgICBdO1xuXG4gICAgZmdQcm9wc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcCBpbiBkaWZmOyB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHApIHsgY29tcC5mb3JjZUdyYXBoW3BdKGVsRGF0YVtwXSAhPT0gJycgPyBlbERhdGFbcF0gOiBudWxsKTsgfSk7IC8vIENvbnZlcnQgYmxhbmsgdmFsdWVzIGludG8gbnVsbHNcblxuICAgIGlmICgnbm9kZXMnIGluIGRpZmYgfHwgJ2xpbmtzJyBpbiBkaWZmKSB7XG4gICAgICBjb21wLmZvcmNlR3JhcGguZ3JhcGhEYXRhKHtcbiAgICAgICAgbm9kZXM6IGVsRGF0YS5ub2RlcyxcbiAgICAgICAgbGlua3M6IGVsRGF0YS5saW5rc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uICh0LCB0ZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuZGF0YTtcblxuICAgIC8vIFVwZGF0ZSBob3ZlciAoaW50ZXJzZWN0ZWQpIG9iamVjdFxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHN0YXRlLmhvdmVyRGV0YWlsXG4gICAgICA/IHN0YXRlLmhvdmVyRGV0YWlsLmdldEludGVyc2VjdGlvblxuICAgICAgICA/IHN0YXRlLmhvdmVyRGV0YWlsLmdldEludGVyc2VjdGlvbih0aGlzLmVsKSAvLyBhdmFpbGFibGUgaW4gcmF5Y2FzdGVyLWludGVyc2VjdGVkIGV2ZW50c1xuICAgICAgICA6IHN0YXRlLmhvdmVyRGV0YWlsLmludGVyc2VjdGlvbiB8fCB1bmRlZmluZWQgLy8gYXZhaWxhYmxlIGluIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSBldmVudHMgKHdpdGggZGVsYXllZCB1cGRhdGUpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE5vdGU6XG4gICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBvbmx5IGhhdmUgYWNjZXNzIHRvIHRoZSBpbnRlcnNlY3RlZCBvYmplY3QgY2xvc2VyIHRvIHRoZSBjYW1lcmEgKDFzdCBlbGVtZW50IGluIHRoZSByYXljYXN0ZXIgaW50ZXJzZWN0T2JqZWN0cyByZXN1bHQpLFxuICAgIC8vIHRoZXJlIGlzIG5vIFwiLmdldEludGVyc2VjdGlvbnMoKVwiIG1ldGhvZCBhdmFpbGFibGUgaW4gdGhlIGV2ZW50IGRldGFpbHMuIFRoZXJlZm9yZSwgd2UgY2FuJ3QgcHJpb3JpdGl6ZSBob3ZlciBvbiBub2RlcyBvdmVyIGxpbmtzLCBvciBldmVuIGV4Y2x1ZGVcbiAgICAvLyBvYmplY3RzIHRoYXQgYXJlIG5laXRoZXIgbm9kZXMgb3IgbGlua3MuIFRoaXMgbWFrZXMgdGhlIGludGVyYWN0aW9uIGEgYml0IGVycmF0aWMgaWYgbm9kZXMgaGF2ZSBhIGxvdCBvZiBsaW5rcyBpbiBmcm9udC5cbiAgICAvLyBDb25maWd1cmluZyB0aGUgcmF5Y2FzdGVyLnBhcmFtcy5MaW5lLnRocmVzaG9sZCBtaWdodCBoZWxwIHdpdGggdGhpcyBzb21ld2hhdCwgYnV0IHRoYXQgY29uZmlnIGlzIGFsc28gbm90IGF2YWlsYWJsZSB2aWEgdGhlIGEtZnJhbWUgcmF5Y2FzdGVyIGNvbXBvbmVudC5cblxuICAgIC8vIHJlY3Vyc2UgdXAgdW50aWwgZm9yY2VncmFwaCBvYmogaXMgZm91bmRcbiAgICBsZXQgdG9wT2JqZWN0ID0gaW50ZXJzZWN0aW9uID8gaW50ZXJzZWN0aW9uLm9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAodG9wT2JqZWN0ICYmICF0b3BPYmplY3QuaGFzT3duUHJvcGVydHkoJ19fZ3JhcGhPYmpUeXBlJykpXG4gICAgICB0b3BPYmplY3QgPSB0b3BPYmplY3QucGFyZW50O1xuXG4gICAgaWYgKHRvcE9iamVjdCAhPT0gc3RhdGUuaG92ZXJPYmopIHtcbiAgICAgIGNvbnN0IHByZXZPYmpUeXBlID0gc3RhdGUuaG92ZXJPYmogPyBzdGF0ZS5ob3Zlck9iai5fX2dyYXBoT2JqVHlwZSA6IG51bGw7XG4gICAgICBjb25zdCBwcmV2T2JqRGF0YSA9IHN0YXRlLmhvdmVyT2JqID8gc3RhdGUuaG92ZXJPYmouX19kYXRhIDogbnVsbDtcbiAgICAgIGNvbnN0IG9ialR5cGUgPSB0b3BPYmplY3QgPyB0b3BPYmplY3QuX19ncmFwaE9ialR5cGUgOiBudWxsO1xuICAgICAgY29uc3Qgb2JqRGF0YSA9IHRvcE9iamVjdCA/IHRvcE9iamVjdC5fX2RhdGEgOiBudWxsO1xuXG4gICAgICBpZiAocHJldk9ialR5cGUgJiYgcHJldk9ialR5cGUgIT09IG9ialR5cGUpIHtcbiAgICAgICAgLy8gSG92ZXIgb3V0XG4gICAgICAgIHByb3BzWydvbicgKyAocHJldk9ialR5cGUgPT09ICdub2RlJyA/ICdOb2RlJyA6ICdMaW5rJykgKyAnSG92ZXInXShudWxsLCBwcmV2T2JqRGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqVHlwZSkge1xuICAgICAgICAvLyBIb3ZlciBpblxuICAgICAgICBwcm9wc1snb24nICsgKG9ialR5cGUgPT09ICdub2RlJyA/ICdOb2RlJyA6ICdMaW5rJykgKyAnSG92ZXInXShvYmpEYXRhLCBwcmV2T2JqVHlwZSA9PT0gb2JqVHlwZSA/IHByZXZPYmpEYXRhIDogbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmhvdmVyT2JqID0gdG9wT2JqZWN0O1xuICAgIH1cblxuICAgIC8vIFJ1biBmb3JjZS1ncmFwaCB0aWNrZXJcbiAgICB0aGlzLmZvcmNlR3JhcGgudGlja0ZyYW1lKCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.167.1/node_modules/aframe-forcegraph-component/index.js\n");

/***/ })

};
;