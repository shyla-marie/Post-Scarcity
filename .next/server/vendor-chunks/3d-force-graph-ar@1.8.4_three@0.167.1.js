"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/3d-force-graph-ar@1.8.4_three@0.167.1";
exports.ids = ["vendor-chunks/3d-force-graph-ar@1.8.4_three@0.167.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/3d-force-graph-ar@1.8.4_three@0.167.1/node_modules/3d-force-graph-ar/dist/3d-force-graph-ar.mjs":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/3d-force-graph-ar@1.8.4_three@0.167.1/node_modules/3d-force-graph-ar/dist/3d-force-graph-ar.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _3dForceGraphAr)\n/* harmony export */ });\n/* harmony import */ var aframe_forcegraph_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aframe-forcegraph-component */ \"(ssr)/./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.167.1/node_modules/aframe-forcegraph-component/index.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/.pnpm/kapsule@1.14.5/node_modules/kapsule/dist/kapsule.mjs\");\n\n\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\n//\n\nvar _3dForceGraphAr = (0,kapsule__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  props: {\n    width: {},\n    height: {},\n    yOffset: {\n      \"default\": 1.5\n    },\n    // marker size units\n    glScale: {\n      \"default\": 200\n    },\n    // gl units per marker width\n    jsonUrl: {},\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      }\n    },\n    numDimensions: {\n      \"default\": 3\n    },\n    dagMode: {},\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default() {\n        return true;\n      }\n    },\n    onDagError: {\n      \"default\": undefined\n    },\n    nodeRelSize: {\n      \"default\": 4\n    },\n    // volume per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val'\n    },\n    nodeResolution: {\n      \"default\": 8\n    },\n    // how many slice segments in the sphere's circumference\n    nodeVisibility: {\n      \"default\": true\n    },\n    nodeColor: {\n      \"default\": 'color'\n    },\n    nodeAutoColorBy: {},\n    nodeOpacity: {\n      \"default\": 0.75\n    },\n    nodeThreeObject: {},\n    nodeThreeObjectExtend: {\n      \"default\": false\n    },\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true\n    },\n    linkColor: {\n      \"default\": 'color'\n    },\n    linkAutoColorBy: {},\n    linkOpacity: {\n      \"default\": 0.2\n    },\n    linkWidth: {\n      \"default\": 0\n    },\n    linkResolution: {\n      \"default\": 6\n    },\n    // how many radial segments in each line cylinder's geometry\n    linkCurvature: {\n      \"default\": 0\n    },\n    linkCurveRotation: {\n      \"default\": 0\n    },\n    linkMaterial: {},\n    linkThreeObject: {},\n    linkThreeObjectExtend: {\n      \"default\": false\n    },\n    linkPositionUpdate: {},\n    linkDirectionalArrowLength: {\n      \"default\": 0\n    },\n    linkDirectionalArrowColor: {},\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: {\n      \"default\": 8\n    },\n    // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: {\n      \"default\": 0\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \"default\": 0.5\n    },\n    linkDirectionalParticleColor: {},\n    linkDirectionalParticleResolution: {\n      \"default\": 4\n    },\n    // how many slice segments in the particle sphere's circumference\n    onNodeHover: {},\n    onNodeClick: {},\n    onLinkHover: {},\n    onLinkClick: {},\n    forceEngine: {\n      \"default\": 'd3'\n    },\n    // d3 or ngraph\n    d3AlphaMin: {\n      \"default\": 0\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4\n    },\n    ngraphPhysics: {},\n    warmupTicks: {\n      \"default\": 0\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {},\n    cooldownTime: {\n      \"default\": 15000\n    },\n    // ms\n    onEngineTick: {},\n    onEngineStop: {}\n  },\n  methods: _objectSpread2(_objectSpread2({}, Object.assign.apply(Object, [{}].concat(_toConsumableArray(['getGraphBbox', 'emitParticle', 'd3Force', 'd3ReheatSimulation', 'refresh'].map(function (method) {\n    return _defineProperty({}, method, function (state) {\n      var aframeComp = state.forcegraph.components.forcegraph;\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      var returnVal = aframeComp[method].apply(aframeComp, args);\n      return returnVal === aframeComp ? this // chain based on this object, not the inner aframe component\n      : returnVal;\n    });\n  }))))), {}, {\n    _destructor: function _destructor() {\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }),\n  init: function init(domNode, state) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$markerAttrs = _ref2.markerAttrs,\n      markerAttrs = _ref2$markerAttrs === void 0 ? {\n        preset: 'hiro'\n      } : _ref2$markerAttrs;\n    // Wipe DOM\n    domNode.innerHTML = '';\n    state.container = document.createElement('div');\n    domNode.appendChild(state.container);\n\n    // Create scene\n    var scene = document.createElement('a-scene');\n    scene.setAttribute('embedded', '');\n    scene.setAttribute('vr-mode-ui', 'enabled: false');\n    scene.setAttribute('arjs', 'debugUIEnabled: false;');\n    var arMarker = document.createElement('a-marker');\n    // add marker attributes\n    Object.entries(markerAttrs).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        attr = _ref4[0],\n        val = _ref4[1];\n      return arMarker.setAttribute(attr, val);\n    });\n    scene.appendChild(arMarker);\n\n    // Setup raycaster cursor\n    var mouseCursor;\n    scene.appendChild(mouseCursor = document.createElement('a-entity'));\n    mouseCursor.setAttribute('cursor' /*, 'rayOrigin: mouse'*/); // mouse raycaster has accuracy issues in ar.js: https://github.com/AR-js-org/AR.js/issues/40\n    mouseCursor.setAttribute('raycaster', 'objects: [forcegraph]');\n\n    // Add forcegraph entity\n    state.forcegraph = document.createElement('a-entity');\n    state.forcegraph.setAttribute('forcegraph', null);\n    arMarker.appendChild(state.forcegraph);\n    var cameraEntity = document.createElement('a-entity');\n    cameraEntity.setAttribute('camera', '');\n    scene.appendChild(cameraEntity);\n\n    // attach scene\n    state.container.appendChild(scene);\n    //domNode.appendChild(scene);\n  },\n  update: function update(state, changedProps) {\n    changedProps.hasOwnProperty('width') && state.width && (state.container.style.width = \"\".concat(state.width, \"px\"));\n    changedProps.hasOwnProperty('height') && state.height && (state.container.style.height = \"\".concat(state.height, \"px\"));\n    changedProps.hasOwnProperty('glScale') && state.forcegraph.setAttribute('scale', _toConsumableArray(new Array(3)).map(function () {\n      return 1 / state.glScale;\n    }).join(' '));\n    changedProps.hasOwnProperty('yOffset') && state.forcegraph.setAttribute('position', \"0 \".concat(state.yOffset, \" 0\"));\n    var passThroughProps = ['jsonUrl', 'numDimensions', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'nodeRelSize', 'nodeId', 'nodeVal', 'nodeResolution', 'nodeVisibility', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeThreeObject', 'nodeThreeObjectExtend', 'linkSource', 'linkTarget', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkThreeObjectExtend', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'onNodeHover', 'onNodeClick', 'onLinkHover', 'onLinkClick', 'forceEngine', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'ngraphPhysics', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'];\n    var newProps = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(state).filter(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        prop = _ref6[0],\n        val = _ref6[1];\n      return changedProps.hasOwnProperty(prop) && passThroughProps.indexOf(prop) !== -1 && val !== undefined && val !== null;\n    }).map(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n        key = _ref8[0],\n        val = _ref8[1];\n      return _defineProperty({}, key, val);\n    })), _toConsumableArray(Object.entries(state.graphData).map(function (_ref10) {\n      var _ref11 = _slicedToArray(_ref10, 2),\n        key = _ref11[0],\n        val = _ref11[1];\n      return _defineProperty({}, key, val);\n    }))));\n    state.forcegraph.setAttribute('forcegraph', newProps);\n  }\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vM2QtZm9yY2UtZ3JhcGgtYXJAMS44LjRfdGhyZWVAMC4xNjcuMS9ub2RlX21vZHVsZXMvM2QtZm9yY2UtZ3JhcGgtYXIvZGlzdC8zZC1mb3JjZS1ncmFwaC1hci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ1A7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksa0VBQWtFO0FBQ3RGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsbURBQU87QUFDN0I7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsMkNBQTJDLGlDQUFpQztBQUM1RSw2QkFBNkI7QUFDN0I7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsU0FBUztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hX3Bvc3Rfc2NhcmNpdHkvLi9ub2RlX21vZHVsZXMvLnBucG0vM2QtZm9yY2UtZ3JhcGgtYXJAMS44LjRfdGhyZWVAMC4xNjcuMS9ub2RlX21vZHVsZXMvM2QtZm9yY2UtZ3JhcGgtYXIvZGlzdC8zZC1mb3JjZS1ncmFwaC1hci5tanM/MGUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2FmcmFtZS1mb3JjZWdyYXBoLWNvbXBvbmVudCc7XG5pbXBvcnQgS2Fwc3VsZSBmcm9tICdrYXBzdWxlJztcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbi8vXG5cbnZhciBfM2RGb3JjZUdyYXBoQXIgPSBLYXBzdWxlKHtcbiAgcHJvcHM6IHtcbiAgICB3aWR0aDoge30sXG4gICAgaGVpZ2h0OiB7fSxcbiAgICB5T2Zmc2V0OiB7XG4gICAgICBcImRlZmF1bHRcIjogMS41XG4gICAgfSxcbiAgICAvLyBtYXJrZXIgc2l6ZSB1bml0c1xuICAgIGdsU2NhbGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAyMDBcbiAgICB9LFxuICAgIC8vIGdsIHVuaXRzIHBlciBtYXJrZXIgd2lkdGhcbiAgICBqc29uVXJsOiB7fSxcbiAgICBncmFwaERhdGE6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9XG4gICAgfSxcbiAgICBudW1EaW1lbnNpb25zOiB7XG4gICAgICBcImRlZmF1bHRcIjogM1xuICAgIH0sXG4gICAgZGFnTW9kZToge30sXG4gICAgZGFnTGV2ZWxEaXN0YW5jZToge30sXG4gICAgZGFnTm9kZUZpbHRlcjoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRGFnRXJyb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB1bmRlZmluZWRcbiAgICB9LFxuICAgIG5vZGVSZWxTaXplOiB7XG4gICAgICBcImRlZmF1bHRcIjogNFxuICAgIH0sXG4gICAgLy8gdm9sdW1lIHBlciB2YWwgdW5pdFxuICAgIG5vZGVJZDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdpZCdcbiAgICB9LFxuICAgIG5vZGVWYWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAndmFsJ1xuICAgIH0sXG4gICAgbm9kZVJlc29sdXRpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA4XG4gICAgfSxcbiAgICAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgc3BoZXJlJ3MgY2lyY3VtZmVyZW5jZVxuICAgIG5vZGVWaXNpYmlsaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gICAgbm9kZUNvbG9yOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2NvbG9yJ1xuICAgIH0sXG4gICAgbm9kZUF1dG9Db2xvckJ5OiB7fSxcbiAgICBub2RlT3BhY2l0eToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNzVcbiAgICB9LFxuICAgIG5vZGVUaHJlZU9iamVjdDoge30sXG4gICAgbm9kZVRocmVlT2JqZWN0RXh0ZW5kOiB7XG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtTb3VyY2U6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnc291cmNlJ1xuICAgIH0sXG4gICAgbGlua1RhcmdldDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICd0YXJnZXQnXG4gICAgfSxcbiAgICBsaW5rVmlzaWJpbGl0eToge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIGxpbmtDb2xvcjoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdjb2xvcidcbiAgICB9LFxuICAgIGxpbmtBdXRvQ29sb3JCeToge30sXG4gICAgbGlua09wYWNpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjJcbiAgICB9LFxuICAgIGxpbmtXaWR0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9LFxuICAgIGxpbmtSZXNvbHV0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogNlxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgcmFkaWFsIHNlZ21lbnRzIGluIGVhY2ggbGluZSBjeWxpbmRlcidzIGdlb21ldHJ5XG4gICAgbGlua0N1cnZhdHVyZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9LFxuICAgIGxpbmtDdXJ2ZVJvdGF0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogMFxuICAgIH0sXG4gICAgbGlua01hdGVyaWFsOiB7fSxcbiAgICBsaW5rVGhyZWVPYmplY3Q6IHt9LFxuICAgIGxpbmtUaHJlZU9iamVjdEV4dGVuZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rUG9zaXRpb25VcGRhdGU6IHt9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMFxuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcjoge30sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjVcbiAgICB9LFxuICAgIC8vIHZhbHVlIGJldHdlZW4gMDw+MSBpbmRpY2F0aW5nIHRoZSByZWxhdGl2ZSBwb3MgYWxvbmcgdGhlIChleHBvc2VkKSBsaW5lXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dSZXNvbHV0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogOFxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgc2xpY2Ugc2VnbWVudHMgaW4gdGhlIGFycm93J3MgY29uaWMgY2lyY3VtZmVyZW5jZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDBcbiAgICB9LFxuICAgIC8vIGFuaW1hdGUgcGhvdG9ucyB0cmF2ZWxsaW5nIGluIHRoZSBsaW5rIGRpcmVjdGlvblxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAxXG4gICAgfSxcbiAgICAvLyBpbiBsaW5rIGxlbmd0aCByYXRpbyBwZXIgZnJhbWVcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC41XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yOiB7fSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0XG4gICAgfSxcbiAgICAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgcGFydGljbGUgc3BoZXJlJ3MgY2lyY3VtZmVyZW5jZVxuICAgIG9uTm9kZUhvdmVyOiB7fSxcbiAgICBvbk5vZGVDbGljazoge30sXG4gICAgb25MaW5rSG92ZXI6IHt9LFxuICAgIG9uTGlua0NsaWNrOiB7fSxcbiAgICBmb3JjZUVuZ2luZToge1xuICAgICAgXCJkZWZhdWx0XCI6ICdkMydcbiAgICB9LFxuICAgIC8vIGQzIG9yIG5ncmFwaFxuICAgIGQzQWxwaGFNaW46IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwXG4gICAgfSxcbiAgICBkM0FscGhhRGVjYXk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAyMjhcbiAgICB9LFxuICAgIGQzVmVsb2NpdHlEZWNheToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNFxuICAgIH0sXG4gICAgbmdyYXBoUGh5c2ljczoge30sXG4gICAgd2FybXVwVGlja3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwXG4gICAgfSxcbiAgICAvLyBob3cgbWFueSB0aW1lcyB0byB0aWNrIHRoZSBmb3JjZSBlbmdpbmUgYXQgaW5pdCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVuZGVyXG4gICAgY29vbGRvd25UaWNrczoge30sXG4gICAgY29vbGRvd25UaW1lOiB7XG4gICAgICBcImRlZmF1bHRcIjogMTUwMDBcbiAgICB9LFxuICAgIC8vIG1zXG4gICAgb25FbmdpbmVUaWNrOiB7fSxcbiAgICBvbkVuZ2luZVN0b3A6IHt9XG4gIH0sXG4gIG1ldGhvZHM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3t9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KFsnZ2V0R3JhcGhCYm94JywgJ2VtaXRQYXJ0aWNsZScsICdkM0ZvcmNlJywgJ2QzUmVoZWF0U2ltdWxhdGlvbicsICdyZWZyZXNoJ10ubWFwKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBtZXRob2QsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIGFmcmFtZUNvbXAgPSBzdGF0ZS5mb3JjZWdyYXBoLmNvbXBvbmVudHMuZm9yY2VncmFwaDtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuVmFsID0gYWZyYW1lQ29tcFttZXRob2RdLmFwcGx5KGFmcmFtZUNvbXAsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbCA9PT0gYWZyYW1lQ29tcCA/IHRoaXMgLy8gY2hhaW4gYmFzZWQgb24gdGhpcyBvYmplY3QsIG5vdCB0aGUgaW5uZXIgYWZyYW1lIGNvbXBvbmVudFxuICAgICAgOiByZXR1cm5WYWw7XG4gICAgfSk7XG4gIH0pKSkpKSwge30sIHtcbiAgICBfZGVzdHJ1Y3RvcjogZnVuY3Rpb24gX2Rlc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmdyYXBoRGF0YSh7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbU5vZGUsIHN0YXRlKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIF9yZWYyJG1hcmtlckF0dHJzID0gX3JlZjIubWFya2VyQXR0cnMsXG4gICAgICBtYXJrZXJBdHRycyA9IF9yZWYyJG1hcmtlckF0dHJzID09PSB2b2lkIDAgPyB7XG4gICAgICAgIHByZXNldDogJ2hpcm8nXG4gICAgICB9IDogX3JlZjIkbWFya2VyQXR0cnM7XG4gICAgLy8gV2lwZSBET01cbiAgICBkb21Ob2RlLmlubmVySFRNTCA9ICcnO1xuICAgIHN0YXRlLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbU5vZGUuYXBwZW5kQ2hpbGQoc3RhdGUuY29udGFpbmVyKTtcblxuICAgIC8vIENyZWF0ZSBzY2VuZVxuICAgIHZhciBzY2VuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Etc2NlbmUnKTtcbiAgICBzY2VuZS5zZXRBdHRyaWJ1dGUoJ2VtYmVkZGVkJywgJycpO1xuICAgIHNjZW5lLnNldEF0dHJpYnV0ZSgndnItbW9kZS11aScsICdlbmFibGVkOiBmYWxzZScpO1xuICAgIHNjZW5lLnNldEF0dHJpYnV0ZSgnYXJqcycsICdkZWJ1Z1VJRW5hYmxlZDogZmFsc2U7Jyk7XG4gICAgdmFyIGFyTWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1tYXJrZXInKTtcbiAgICAvLyBhZGQgbWFya2VyIGF0dHJpYnV0ZXNcbiAgICBPYmplY3QuZW50cmllcyhtYXJrZXJBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgYXR0ciA9IF9yZWY0WzBdLFxuICAgICAgICB2YWwgPSBfcmVmNFsxXTtcbiAgICAgIHJldHVybiBhck1hcmtlci5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKTtcbiAgICB9KTtcbiAgICBzY2VuZS5hcHBlbmRDaGlsZChhck1hcmtlcik7XG5cbiAgICAvLyBTZXR1cCByYXljYXN0ZXIgY3Vyc29yXG4gICAgdmFyIG1vdXNlQ3Vyc29yO1xuICAgIHNjZW5lLmFwcGVuZENoaWxkKG1vdXNlQ3Vyc29yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKSk7XG4gICAgbW91c2VDdXJzb3Iuc2V0QXR0cmlidXRlKCdjdXJzb3InIC8qLCAncmF5T3JpZ2luOiBtb3VzZScqLyk7IC8vIG1vdXNlIHJheWNhc3RlciBoYXMgYWNjdXJhY3kgaXNzdWVzIGluIGFyLmpzOiBodHRwczovL2dpdGh1Yi5jb20vQVItanMtb3JnL0FSLmpzL2lzc3Vlcy80MFxuICAgIG1vdXNlQ3Vyc29yLnNldEF0dHJpYnV0ZSgncmF5Y2FzdGVyJywgJ29iamVjdHM6IFtmb3JjZWdyYXBoXScpO1xuXG4gICAgLy8gQWRkIGZvcmNlZ3JhcGggZW50aXR5XG4gICAgc3RhdGUuZm9yY2VncmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EtZW50aXR5Jyk7XG4gICAgc3RhdGUuZm9yY2VncmFwaC5zZXRBdHRyaWJ1dGUoJ2ZvcmNlZ3JhcGgnLCBudWxsKTtcbiAgICBhck1hcmtlci5hcHBlbmRDaGlsZChzdGF0ZS5mb3JjZWdyYXBoKTtcbiAgICB2YXIgY2FtZXJhRW50aXR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICBjYW1lcmFFbnRpdHkuc2V0QXR0cmlidXRlKCdjYW1lcmEnLCAnJyk7XG4gICAgc2NlbmUuYXBwZW5kQ2hpbGQoY2FtZXJhRW50aXR5KTtcblxuICAgIC8vIGF0dGFjaCBzY2VuZVxuICAgIHN0YXRlLmNvbnRhaW5lci5hcHBlbmRDaGlsZChzY2VuZSk7XG4gICAgLy9kb21Ob2RlLmFwcGVuZENoaWxkKHNjZW5lKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoc3RhdGUsIGNoYW5nZWRQcm9wcykge1xuICAgIGNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSAmJiBzdGF0ZS53aWR0aCAmJiAoc3RhdGUuY29udGFpbmVyLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoc3RhdGUud2lkdGgsIFwicHhcIikpO1xuICAgIGNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykgJiYgc3RhdGUuaGVpZ2h0ICYmIChzdGF0ZS5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoc3RhdGUuaGVpZ2h0LCBcInB4XCIpKTtcbiAgICBjaGFuZ2VkUHJvcHMuaGFzT3duUHJvcGVydHkoJ2dsU2NhbGUnKSAmJiBzdGF0ZS5mb3JjZWdyYXBoLnNldEF0dHJpYnV0ZSgnc2NhbGUnLCBfdG9Db25zdW1hYmxlQXJyYXkobmV3IEFycmF5KDMpKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDEgLyBzdGF0ZS5nbFNjYWxlO1xuICAgIH0pLmpvaW4oJyAnKSk7XG4gICAgY2hhbmdlZFByb3BzLmhhc093blByb3BlcnR5KCd5T2Zmc2V0JykgJiYgc3RhdGUuZm9yY2VncmFwaC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgXCIwIFwiLmNvbmNhdChzdGF0ZS55T2Zmc2V0LCBcIiAwXCIpKTtcbiAgICB2YXIgcGFzc1Rocm91Z2hQcm9wcyA9IFsnanNvblVybCcsICdudW1EaW1lbnNpb25zJywgJ2RhZ01vZGUnLCAnZGFnTGV2ZWxEaXN0YW5jZScsICdkYWdOb2RlRmlsdGVyJywgJ29uRGFnRXJyb3InLCAnbm9kZVJlbFNpemUnLCAnbm9kZUlkJywgJ25vZGVWYWwnLCAnbm9kZVJlc29sdXRpb24nLCAnbm9kZVZpc2liaWxpdHknLCAnbm9kZUNvbG9yJywgJ25vZGVBdXRvQ29sb3JCeScsICdub2RlT3BhY2l0eScsICdub2RlVGhyZWVPYmplY3QnLCAnbm9kZVRocmVlT2JqZWN0RXh0ZW5kJywgJ2xpbmtTb3VyY2UnLCAnbGlua1RhcmdldCcsICdsaW5rVmlzaWJpbGl0eScsICdsaW5rQ29sb3InLCAnbGlua0F1dG9Db2xvckJ5JywgJ2xpbmtPcGFjaXR5JywgJ2xpbmtXaWR0aCcsICdsaW5rUmVzb2x1dGlvbicsICdsaW5rQ3VydmF0dXJlJywgJ2xpbmtDdXJ2ZVJvdGF0aW9uJywgJ2xpbmtNYXRlcmlhbCcsICdsaW5rVGhyZWVPYmplY3QnLCAnbGlua1RocmVlT2JqZWN0RXh0ZW5kJywgJ2xpbmtQb3NpdGlvblVwZGF0ZScsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCcsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93UmVsUG9zJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbicsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3InLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVSZXNvbHV0aW9uJywgJ29uTm9kZUhvdmVyJywgJ29uTm9kZUNsaWNrJywgJ29uTGlua0hvdmVyJywgJ29uTGlua0NsaWNrJywgJ2ZvcmNlRW5naW5lJywgJ2QzQWxwaGFNaW4nLCAnZDNBbHBoYURlY2F5JywgJ2QzVmVsb2NpdHlEZWNheScsICduZ3JhcGhQaHlzaWNzJywgJ3dhcm11cFRpY2tzJywgJ2Nvb2xkb3duVGlja3MnLCAnY29vbGRvd25UaW1lJywgJ29uRW5naW5lVGljaycsICdvbkVuZ2luZVN0b3AnXTtcbiAgICB2YXIgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3t9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5lbnRyaWVzKHN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICAgIHByb3AgPSBfcmVmNlswXSxcbiAgICAgICAgdmFsID0gX3JlZjZbMV07XG4gICAgICByZXR1cm4gY2hhbmdlZFByb3BzLmhhc093blByb3BlcnR5KHByb3ApICYmIHBhc3NUaHJvdWdoUHJvcHMuaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAyKSxcbiAgICAgICAga2V5ID0gX3JlZjhbMF0sXG4gICAgICAgIHZhbCA9IF9yZWY4WzFdO1xuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWwpO1xuICAgIH0pKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5lbnRyaWVzKHN0YXRlLmdyYXBoRGF0YSkubWFwKGZ1bmN0aW9uIChfcmVmMTApIHtcbiAgICAgIHZhciBfcmVmMTEgPSBfc2xpY2VkVG9BcnJheShfcmVmMTAsIDIpLFxuICAgICAgICBrZXkgPSBfcmVmMTFbMF0sXG4gICAgICAgIHZhbCA9IF9yZWYxMVsxXTtcbiAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsKTtcbiAgICB9KSkpKTtcbiAgICBzdGF0ZS5mb3JjZWdyYXBoLnNldEF0dHJpYnV0ZSgnZm9yY2VncmFwaCcsIG5ld1Byb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF8zZEZvcmNlR3JhcGhBciBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/3d-force-graph-ar@1.8.4_three@0.167.1/node_modules/3d-force-graph-ar/dist/3d-force-graph-ar.mjs\n");

/***/ })

};
;