"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/3d-force-graph@1.73.3";
exports.ids = ["vendor-chunks/3d-force-graph@1.73.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/3d-force-graph@1.73.3/node_modules/3d-force-graph/dist/3d-force-graph.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/3d-force-graph@1.73.3/node_modules/3d-force-graph/dist/3d-force-graph.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _3dForceGraph)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.167.1/node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_controls_DragControls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/controls/DragControls.js */ \"(ssr)/./node_modules/.pnpm/three@0.167.1/node_modules/three/examples/jsm/controls/DragControls.js\");\n/* harmony import */ var three_forcegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-forcegraph */ \"(ssr)/./node_modules/.pnpm/three-forcegraph@1.41.14_three@0.167.1/node_modules/three-forcegraph/dist/three-forcegraph.mjs\");\n/* harmony import */ var three_render_objects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-render-objects */ \"(ssr)/./node_modules/.pnpm/three-render-objects@1.29.4_three@0.167.1/node_modules/three-render-objects/dist/three-render-objects.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/.pnpm/accessor-fn@1.5.1/node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/.pnpm/kapsule@1.14.5/node_modules/kapsule/dist/kapsule.mjs\");\n\n\n\n\n\n\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".graph-info-msg {\\n  top: 50%;\\n  width: 100%;\\n  text-align: center;\\n  color: lavender;\\n  opacity: 0.7;\\n  font-size: 22px;\\n  position: absolute;\\n  font-family: Sans-serif;\\n}\\n\\n.scene-container .clickable {\\n  cursor: pointer;\\n}\\n\\n.scene-container .grabbable {\\n  cursor: move;\\n  cursor: grab;\\n  cursor: -moz-grab;\\n  cursor: -webkit-grab;\\n}\\n\\n.scene-container .grabbable:active {\\n  cursor: grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: -webkit-grabbing;\\n}\";\nstyleInject(css_248z);\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction linkKapsule (kapsulePropName, kapsuleType) {\n  var dummyK = new kapsuleType(); // To extract defaults\n  dummyK._destructor && dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n      // link property config\n      return {\n        \"default\": dummyK[prop](),\n        onChange: function onChange(v, state) {\n          state[kapsulePropName][prop](v);\n        },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: function linkMethod(method) {\n      // link method pass-through\n      return function (state) {\n        var kapsuleInstance = state[kapsulePropName];\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n        return returnVal === kapsuleInstance ? this // chain based on the parent object, not the inner kapsule\n        : returnVal;\n      };\n    }\n  };\n}\n\nvar three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  AmbientLight: three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight,\n  DirectionalLight: three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight,\n  Vector3: three__WEBPACK_IMPORTED_MODULE_1__.Vector3,\n  REVISION: three__WEBPACK_IMPORTED_MODULE_1__.REVISION\n};\n\n//\n\nvar CAMERA_DISTANCE2NODES_FACTOR = 170;\n\n//\n\n// Expose config from forceGraph\nvar bindFG = linkKapsule('forceGraph', three_forcegraph__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nvar linkedFGProps = Object.assign.apply(Object, _toConsumableArray(['jsonUrl', 'graphData', 'numDimensions', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'nodeRelSize', 'nodeId', 'nodeVal', 'nodeResolution', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeVisibility', 'nodeThreeObject', 'nodeThreeObjectExtend', 'linkSource', 'linkTarget', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkThreeObjectExtend', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'forceEngine', 'd3AlphaDecay', 'd3VelocityDecay', 'd3AlphaMin', 'ngraphPhysics', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkProp(p));\n})));\nvar linkedFGMethods = Object.assign.apply(Object, _toConsumableArray(['refresh', 'getGraphBbox', 'd3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkMethod(p));\n})));\n\n// Expose config from renderObjs\nvar bindRenderObjs = linkKapsule('renderObjs', three_render_objects__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar linkedRenderObjsProps = Object.assign.apply(Object, _toConsumableArray(['width', 'height', 'backgroundColor', 'showNavInfo', 'enablePointerInteraction'].map(function (p) {\n  return _defineProperty({}, p, bindRenderObjs.linkProp(p));\n})));\nvar linkedRenderObjsMethods = Object.assign.apply(Object, _toConsumableArray(['lights', 'cameraPosition', 'postProcessingComposer'].map(function (p) {\n  return _defineProperty({}, p, bindRenderObjs.linkMethod(p));\n})).concat([{\n  graph2ScreenCoords: bindRenderObjs.linkMethod('getScreenCoords'),\n  screen2GraphCoords: bindRenderObjs.linkMethod('getSceneCoords')\n}]));\n\n//\n\nvar _3dForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n  props: _objectSpread2(_objectSpread2({\n    nodeLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkHoverPrecision: {\n      \"default\": 1,\n      onChange: function onChange(p, state) {\n        return state.renderObjs.lineHoverPrecision(p);\n      },\n      triggerUpdate: false\n    },\n    enableNavigationControls: {\n      \"default\": true,\n      onChange: function onChange(enable, state) {\n        var controls = state.renderObjs.controls();\n        if (controls) {\n          controls.enabled = enable;\n          // trigger mouseup on re-enable to prevent sticky controls\n          enable && controls.domElement && controls.domElement.dispatchEvent(new PointerEvent('pointerup'));\n        }\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n      triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n    onBackgroundRightClick: {\n      triggerUpdate: false\n    }\n  }, linkedFGProps), linkedRenderObjsProps),\n  methods: _objectSpread2(_objectSpread2({\n    zoomToFit: function zoomToFit(state, transitionDuration, padding) {\n      var _state$forceGraph;\n      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      state.renderObjs.fitToBbox((_state$forceGraph = state.forceGraph).getGraphBbox.apply(_state$forceGraph, bboxArgs), transitionDuration, padding);\n      return this;\n    },\n    pauseAnimation: function pauseAnimation(state) {\n      if (state.animationFrameRequestId !== null) {\n        cancelAnimationFrame(state.animationFrameRequestId);\n        state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n    resumeAnimation: function resumeAnimation(state) {\n      if (state.animationFrameRequestId === null) {\n        this._animationCycle();\n      }\n      return this;\n    },\n    _animationCycle: function _animationCycle(state) {\n      if (state.enablePointerInteraction) {\n        // reset canvas cursor (override dragControls cursor)\n        this.renderer().domElement.style.cursor = null;\n      }\n\n      // Frame cycle\n      state.forceGraph.tickFrame();\n      state.renderObjs.tick();\n      state.animationFrameRequestId = requestAnimationFrame(this._animationCycle);\n    },\n    scene: function scene(state) {\n      return state.renderObjs.scene();\n    },\n    // Expose scene\n    camera: function camera(state) {\n      return state.renderObjs.camera();\n    },\n    // Expose camera\n    renderer: function renderer(state) {\n      return state.renderObjs.renderer();\n    },\n    // Expose renderer\n    controls: function controls(state) {\n      return state.renderObjs.controls();\n    },\n    // Expose controls\n    tbControls: function tbControls(state) {\n      return state.renderObjs.tbControls();\n    },\n    // To be deprecated\n    _destructor: function _destructor() {\n      this.pauseAnimation();\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }, linkedFGMethods), linkedRenderObjsMethods),\n  stateInit: function stateInit(_ref5) {\n    var controlType = _ref5.controlType,\n      rendererConfig = _ref5.rendererConfig,\n      extraRenderers = _ref5.extraRenderers;\n    var forceGraph = new three_forcegraph__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    return {\n      forceGraph: forceGraph,\n      renderObjs: (0,three_render_objects__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n        controlType: controlType,\n        rendererConfig: rendererConfig,\n        extraRenderers: extraRenderers\n      }).objects([forceGraph]) // Populate scene\n      .lights([new three.AmbientLight(0xcccccc, Math.PI), new three.DirectionalLight(0xffffff, 0.6 * Math.PI)])\n    };\n  },\n  init: function init(domNode, state) {\n    // Wipe DOM\n    domNode.innerHTML = '';\n\n    // Add relative container\n    domNode.appendChild(state.container = document.createElement('div'));\n    state.container.style.position = 'relative';\n\n    // Add renderObjs\n    var roDomNode = document.createElement('div');\n    state.container.appendChild(roDomNode);\n    state.renderObjs(roDomNode);\n    var camera = state.renderObjs.camera();\n    var renderer = state.renderObjs.renderer();\n    var controls = state.renderObjs.controls();\n    controls.enabled = !!state.enableNavigationControls;\n    state.lastSetCameraZ = camera.position.z;\n\n    // Add info space\n    var infoElem;\n    state.container.appendChild(infoElem = document.createElement('div'));\n    infoElem.className = 'graph-info-msg';\n    infoElem.textContent = '';\n\n    // config forcegraph\n    state.forceGraph.onLoading(function () {\n      infoElem.textContent = 'Loading...';\n    }).onFinishLoading(function () {\n      infoElem.textContent = '';\n    }).onUpdate(function () {\n      // sync graph data structures\n      state.graphData = state.forceGraph.graphData();\n\n      // re-aim camera, if still in default position (not user modified)\n      if (camera.position.x === 0 && camera.position.y === 0 && camera.position.z === state.lastSetCameraZ && state.graphData.nodes.length) {\n        camera.lookAt(state.forceGraph.position);\n        state.lastSetCameraZ = camera.position.z = Math.cbrt(state.graphData.nodes.length) * CAMERA_DISTANCE2NODES_FACTOR;\n      }\n    }).onFinishUpdate(function () {\n      // Setup node drag interaction\n      if (state._dragControls) {\n        var curNodeDrag = state.graphData.nodes.find(function (node) {\n          return node.__initialFixedPos && !node.__disposeControlsAfterDrag;\n        }); // detect if there's a node being dragged using the existing drag controls\n        if (curNodeDrag) {\n          curNodeDrag.__disposeControlsAfterDrag = true; // postpone previous controls disposal until drag ends\n        } else {\n          state._dragControls.dispose(); // cancel previous drag controls\n        }\n        state._dragControls = undefined;\n      }\n      if (state.enableNodeDrag && state.enablePointerInteraction && state.forceEngine === 'd3') {\n        // Can't access node positions programmatically in ngraph\n        var dragControls = state._dragControls = new three_examples_jsm_controls_DragControls_js__WEBPACK_IMPORTED_MODULE_5__.DragControls(state.graphData.nodes.map(function (node) {\n          return node.__threeObj;\n        }).filter(function (obj) {\n          return obj;\n        }), camera, renderer.domElement);\n        dragControls.addEventListener('dragstart', function (event) {\n          controls.enabled = false; // Disable controls while dragging\n\n          // track drag object movement\n          event.object.__initialPos = event.object.position.clone();\n          event.object.__prevPos = event.object.position.clone();\n          var node = getGraphObj(event.object).__data;\n          !node.__initialFixedPos && (node.__initialFixedPos = {\n            fx: node.fx,\n            fy: node.fy,\n            fz: node.fz\n          });\n          !node.__initialPos && (node.__initialPos = {\n            x: node.x,\n            y: node.y,\n            z: node.z\n          });\n\n          // lock node\n          ['x', 'y', 'z'].forEach(function (c) {\n            return node[\"f\".concat(c)] = node[c];\n          });\n\n          // drag cursor\n          renderer.domElement.classList.add('grabbable');\n        });\n        dragControls.addEventListener('drag', function (event) {\n          var nodeObj = getGraphObj(event.object);\n          if (!event.object.hasOwnProperty('__graphObjType')) {\n            // If dragging a child of the node, update the node object instead\n            var initPos = event.object.__initialPos;\n            var prevPos = event.object.__prevPos;\n            var _newPos = event.object.position;\n            nodeObj.position.add(_newPos.clone().sub(prevPos)); // translate node object by the motion delta\n            prevPos.copy(_newPos);\n            _newPos.copy(initPos); // reset child back to its initial position\n          }\n          var node = nodeObj.__data;\n          var newPos = nodeObj.position;\n          var translate = {\n            x: newPos.x - node.x,\n            y: newPos.y - node.y,\n            z: newPos.z - node.z\n          };\n          // Move fx/fy/fz (and x/y/z) of nodes based on object new position\n          ['x', 'y', 'z'].forEach(function (c) {\n            return node[\"f\".concat(c)] = node[c] = newPos[c];\n          });\n          state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag\n          .resetCountdown(); // prevent freeze while dragging\n\n          node.__dragged = true;\n          state.onNodeDrag(node, translate);\n        });\n        dragControls.addEventListener('dragend', function (event) {\n          delete event.object.__initialPos; // remove tracking attributes\n          delete event.object.__prevPos;\n          var node = getGraphObj(event.object).__data;\n\n          // dispose previous controls if needed\n          if (node.__disposeControlsAfterDrag) {\n            dragControls.dispose();\n            delete node.__disposeControlsAfterDrag;\n          }\n          var initFixedPos = node.__initialFixedPos;\n          var initPos = node.__initialPos;\n          var translate = {\n            x: initPos.x - node.x,\n            y: initPos.y - node.y,\n            z: initPos.z - node.z\n          };\n          if (initFixedPos) {\n            ['x', 'y', 'z'].forEach(function (c) {\n              var fc = \"f\".concat(c);\n              if (initFixedPos[fc] === undefined) {\n                delete node[fc];\n              }\n            });\n            delete node.__initialFixedPos;\n            delete node.__initialPos;\n            if (node.__dragged) {\n              delete node.__dragged;\n              state.onNodeDragEnd(node, translate);\n            }\n          }\n          state.forceGraph.d3AlphaTarget(0) // release engine low intensity\n          .resetCountdown(); // let the engine readjust after releasing fixed nodes\n\n          if (state.enableNavigationControls) {\n            controls.enabled = true; // Re-enable controls\n            controls.domElement && controls.domElement.ownerDocument && controls.domElement.ownerDocument.dispatchEvent(\n            // simulate mouseup to ensure the controls don't take over after dragend\n            new PointerEvent('pointerup', {\n              pointerType: 'touch'\n            }));\n          }\n\n          // clear cursor\n          renderer.domElement.classList.remove('grabbable');\n        });\n      }\n    });\n\n    // config renderObjs\n    three.REVISION < 155 && (state.renderObjs.renderer().useLegacyLights = false); // force behavior for three < 155\n    state.renderObjs.hoverOrderComparator(function (a, b) {\n      // Prioritize graph objects\n      var aObj = getGraphObj(a);\n      if (!aObj) return 1;\n      var bObj = getGraphObj(b);\n      if (!bObj) return -1;\n\n      // Prioritize nodes over links\n      var isNode = function isNode(o) {\n        return o.__graphObjType === 'node';\n      };\n      return isNode(bObj) - isNode(aObj);\n    }).tooltipContent(function (obj) {\n      var graphObj = getGraphObj(obj);\n      return graphObj ? (0,accessor_fn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state[\"\".concat(graphObj.__graphObjType, \"Label\")])(graphObj.__data) || '' : '';\n    }).hoverDuringDrag(false).onHover(function (obj) {\n      // Update tooltip and trigger onHover events\n      var hoverObj = getGraphObj(obj);\n      if (hoverObj !== state.hoverObj) {\n        var prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;\n        var prevObjData = state.hoverObj ? state.hoverObj.__data : null;\n        var objType = hoverObj ? hoverObj.__graphObjType : null;\n        var objData = hoverObj ? hoverObj.__data : null;\n        if (prevObjType && prevObjType !== objType) {\n          // Hover out\n          var fn = state[\"on\".concat(prevObjType === 'node' ? 'Node' : 'Link', \"Hover\")];\n          fn && fn(null, prevObjData);\n        }\n        if (objType) {\n          // Hover in\n          var _fn = state[\"on\".concat(objType === 'node' ? 'Node' : 'Link', \"Hover\")];\n          _fn && _fn(objData, prevObjType === objType ? prevObjData : null);\n        }\n\n        // set pointer if hovered object is clickable\n        renderer.domElement.classList[hoverObj && state[\"on\".concat(objType === 'node' ? 'Node' : 'Link', \"Click\")] || !hoverObj && state.onBackgroundClick ? 'add' : 'remove']('clickable');\n        state.hoverObj = hoverObj;\n      }\n    }).clickAfterDrag(false).onClick(function (obj, ev) {\n      var graphObj = getGraphObj(obj);\n      if (graphObj) {\n        var fn = state[\"on\".concat(graphObj.__graphObjType === 'node' ? 'Node' : 'Link', \"Click\")];\n        fn && fn(graphObj.__data, ev);\n      } else {\n        state.onBackgroundClick && state.onBackgroundClick(ev);\n      }\n    }).onRightClick(function (obj, ev) {\n      // Handle right-click events\n      var graphObj = getGraphObj(obj);\n      if (graphObj) {\n        var fn = state[\"on\".concat(graphObj.__graphObjType === 'node' ? 'Node' : 'Link', \"RightClick\")];\n        fn && fn(graphObj.__data, ev);\n      } else {\n        state.onBackgroundRightClick && state.onBackgroundRightClick(ev);\n      }\n    });\n\n    //\n\n    // Kick-off renderer\n    this._animationCycle();\n  }\n});\n\n//\n\nfunction getGraphObj(object) {\n  var obj = object;\n  // recurse up object chain until finding the graph object\n  while (obj && !obj.hasOwnProperty('__graphObjType')) {\n    obj = obj.parent;\n  }\n  return obj;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vM2QtZm9yY2UtZ3JhcGhAMS43My4zL25vZGVfbW9kdWxlcy8zZC1mb3JjZS1ncmFwaC9kaXN0LzNkLWZvcmNlLWdyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBFO0FBQ0M7QUFDNUI7QUFDTztBQUNqQjtBQUNQOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGFBQWEsZ0JBQWdCLHVCQUF1QixvQkFBb0IsaUJBQWlCLG9CQUFvQix1QkFBdUIsNEJBQTRCLEdBQUcsaUNBQWlDLG9CQUFvQixHQUFHLGlDQUFpQyxpQkFBaUIsaUJBQWlCLHNCQUFzQix5QkFBeUIsR0FBRyx3Q0FBd0MscUJBQXFCLDBCQUEwQiw2QkFBNkIsR0FBRztBQUN4ZTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0IsdURBQVU7QUFDbEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFfcG9zdF9zY2FyY2l0eS8uL25vZGVfbW9kdWxlcy8ucG5wbS8zZC1mb3JjZS1ncmFwaEAxLjczLjMvbm9kZV9tb2R1bGVzLzNkLWZvcmNlLWdyYXBoL2Rpc3QvM2QtZm9yY2UtZ3JhcGgubWpzPzljMjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW1iaWVudExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBWZWN0b3IzLCBSRVZJU0lPTiB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IERyYWdDb250cm9scyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9jb250cm9scy9EcmFnQ29udHJvbHMuanMnO1xuaW1wb3J0IFRocmVlRm9yY2VHcmFwaCBmcm9tICd0aHJlZS1mb3JjZWdyYXBoJztcbmltcG9ydCBUaHJlZVJlbmRlck9iamVjdHMgZnJvbSAndGhyZWUtcmVuZGVyLW9iamVjdHMnO1xuaW1wb3J0IGFjY2Vzc29yRm4gZnJvbSAnYWNjZXNzb3ItZm4nO1xuaW1wb3J0IEthcHN1bGUgZnJvbSAna2Fwc3VsZSc7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmIChyZWYgPT09IHZvaWQgMCkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiLmdyYXBoLWluZm8tbXNnIHtcXG4gIHRvcDogNTAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBjb2xvcjogbGF2ZW5kZXI7XFxuICBvcGFjaXR5OiAwLjc7XFxuICBmb250LXNpemU6IDIycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBmb250LWZhbWlseTogU2Fucy1zZXJpZjtcXG59XFxuXFxuLnNjZW5lLWNvbnRhaW5lciAuY2xpY2thYmxlIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnNjZW5lLWNvbnRhaW5lciAuZ3JhYmJhYmxlIHtcXG4gIGN1cnNvcjogbW92ZTtcXG4gIGN1cnNvcjogZ3JhYjtcXG4gIGN1cnNvcjogLW1vei1ncmFiO1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxufVxcblxcbi5zY2VuZS1jb250YWluZXIgLmdyYWJiYWJsZTphY3RpdmUge1xcbiAgY3Vyc29yOiBncmFiYmluZztcXG4gIGN1cnNvcjogLW1vei1ncmFiYmluZztcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXG59XCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eik7XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBsaW5rS2Fwc3VsZSAoa2Fwc3VsZVByb3BOYW1lLCBrYXBzdWxlVHlwZSkge1xuICB2YXIgZHVtbXlLID0gbmV3IGthcHN1bGVUeXBlKCk7IC8vIFRvIGV4dHJhY3QgZGVmYXVsdHNcbiAgZHVtbXlLLl9kZXN0cnVjdG9yICYmIGR1bW15Sy5fZGVzdHJ1Y3RvcigpO1xuICByZXR1cm4ge1xuICAgIGxpbmtQcm9wOiBmdW5jdGlvbiBsaW5rUHJvcChwcm9wKSB7XG4gICAgICAvLyBsaW5rIHByb3BlcnR5IGNvbmZpZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IGR1bW15S1twcm9wXSgpLFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2Uodiwgc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZVtrYXBzdWxlUHJvcE5hbWVdW3Byb3BdKHYpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGxpbmtNZXRob2Q6IGZ1bmN0aW9uIGxpbmtNZXRob2QobWV0aG9kKSB7XG4gICAgICAvLyBsaW5rIG1ldGhvZCBwYXNzLXRocm91Z2hcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGthcHN1bGVJbnN0YW5jZSA9IHN0YXRlW2thcHN1bGVQcm9wTmFtZV07XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0dXJuVmFsID0ga2Fwc3VsZUluc3RhbmNlW21ldGhvZF0uYXBwbHkoa2Fwc3VsZUluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbCA9PT0ga2Fwc3VsZUluc3RhbmNlID8gdGhpcyAvLyBjaGFpbiBiYXNlZCBvbiB0aGUgcGFyZW50IG9iamVjdCwgbm90IHRoZSBpbm5lciBrYXBzdWxlXG4gICAgICAgIDogcmV0dXJuVmFsO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB0aHJlZSA9IHdpbmRvdy5USFJFRSA/IHdpbmRvdy5USFJFRSAvLyBQcmVmZXIgY29uc3VtcHRpb24gZnJvbSBnbG9iYWwgVEhSRUUsIGlmIGV4aXN0c1xuOiB7XG4gIEFtYmllbnRMaWdodDogQW1iaWVudExpZ2h0LFxuICBEaXJlY3Rpb25hbExpZ2h0OiBEaXJlY3Rpb25hbExpZ2h0LFxuICBWZWN0b3IzOiBWZWN0b3IzLFxuICBSRVZJU0lPTjogUkVWSVNJT05cbn07XG5cbi8vXG5cbnZhciBDQU1FUkFfRElTVEFOQ0UyTk9ERVNfRkFDVE9SID0gMTcwO1xuXG4vL1xuXG4vLyBFeHBvc2UgY29uZmlnIGZyb20gZm9yY2VHcmFwaFxudmFyIGJpbmRGRyA9IGxpbmtLYXBzdWxlKCdmb3JjZUdyYXBoJywgVGhyZWVGb3JjZUdyYXBoKTtcbnZhciBsaW5rZWRGR1Byb3BzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ2pzb25VcmwnLCAnZ3JhcGhEYXRhJywgJ251bURpbWVuc2lvbnMnLCAnZGFnTW9kZScsICdkYWdMZXZlbERpc3RhbmNlJywgJ2RhZ05vZGVGaWx0ZXInLCAnb25EYWdFcnJvcicsICdub2RlUmVsU2l6ZScsICdub2RlSWQnLCAnbm9kZVZhbCcsICdub2RlUmVzb2x1dGlvbicsICdub2RlQ29sb3InLCAnbm9kZUF1dG9Db2xvckJ5JywgJ25vZGVPcGFjaXR5JywgJ25vZGVWaXNpYmlsaXR5JywgJ25vZGVUaHJlZU9iamVjdCcsICdub2RlVGhyZWVPYmplY3RFeHRlbmQnLCAnbGlua1NvdXJjZScsICdsaW5rVGFyZ2V0JywgJ2xpbmtWaXNpYmlsaXR5JywgJ2xpbmtDb2xvcicsICdsaW5rQXV0b0NvbG9yQnknLCAnbGlua09wYWNpdHknLCAnbGlua1dpZHRoJywgJ2xpbmtSZXNvbHV0aW9uJywgJ2xpbmtDdXJ2YXR1cmUnLCAnbGlua0N1cnZlUm90YXRpb24nLCAnbGlua01hdGVyaWFsJywgJ2xpbmtUaHJlZU9iamVjdCcsICdsaW5rVGhyZWVPYmplY3RFeHRlbmQnLCAnbGlua1Bvc2l0aW9uVXBkYXRlJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93Q29sb3InLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3MnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dSZXNvbHV0aW9uJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlcycsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGgnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcicsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb24nLCAnZm9yY2VFbmdpbmUnLCAnZDNBbHBoYURlY2F5JywgJ2QzVmVsb2NpdHlEZWNheScsICdkM0FscGhhTWluJywgJ25ncmFwaFBoeXNpY3MnLCAnd2FybXVwVGlja3MnLCAnY29vbGRvd25UaWNrcycsICdjb29sZG93blRpbWUnLCAnb25FbmdpbmVUaWNrJywgJ29uRW5naW5lU3RvcCddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua1Byb3AocCkpO1xufSkpKTtcbnZhciBsaW5rZWRGR01ldGhvZHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgX3RvQ29uc3VtYWJsZUFycmF5KFsncmVmcmVzaCcsICdnZXRHcmFwaEJib3gnLCAnZDNGb3JjZScsICdkM1JlaGVhdFNpbXVsYXRpb24nLCAnZW1pdFBhcnRpY2xlJ10ubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHAsIGJpbmRGRy5saW5rTWV0aG9kKHApKTtcbn0pKSk7XG5cbi8vIEV4cG9zZSBjb25maWcgZnJvbSByZW5kZXJPYmpzXG52YXIgYmluZFJlbmRlck9ianMgPSBsaW5rS2Fwc3VsZSgncmVuZGVyT2JqcycsIFRocmVlUmVuZGVyT2JqZWN0cyk7XG52YXIgbGlua2VkUmVuZGVyT2Jqc1Byb3BzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ3dpZHRoJywgJ2hlaWdodCcsICdiYWNrZ3JvdW5kQ29sb3InLCAnc2hvd05hdkluZm8nLCAnZW5hYmxlUG9pbnRlckludGVyYWN0aW9uJ10ubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHAsIGJpbmRSZW5kZXJPYmpzLmxpbmtQcm9wKHApKTtcbn0pKSk7XG52YXIgbGlua2VkUmVuZGVyT2Jqc01ldGhvZHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgX3RvQ29uc3VtYWJsZUFycmF5KFsnbGlnaHRzJywgJ2NhbWVyYVBvc2l0aW9uJywgJ3Bvc3RQcm9jZXNzaW5nQ29tcG9zZXInXS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgcCwgYmluZFJlbmRlck9ianMubGlua01ldGhvZChwKSk7XG59KSkuY29uY2F0KFt7XG4gIGdyYXBoMlNjcmVlbkNvb3JkczogYmluZFJlbmRlck9ianMubGlua01ldGhvZCgnZ2V0U2NyZWVuQ29vcmRzJyksXG4gIHNjcmVlbjJHcmFwaENvb3JkczogYmluZFJlbmRlck9ianMubGlua01ldGhvZCgnZ2V0U2NlbmVDb29yZHMnKVxufV0pKTtcblxuLy9cblxudmFyIF8zZEZvcmNlR3JhcGggPSBLYXBzdWxlKHtcbiAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICBub2RlTGFiZWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnbmFtZScsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0xhYmVsOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ25hbWUnLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtIb3ZlclByZWNpc2lvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UocCwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnJlbmRlck9ianMubGluZUhvdmVyUHJlY2lzaW9uKHApO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVOYXZpZ2F0aW9uQ29udHJvbHM6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGVuYWJsZSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xzID0gc3RhdGUucmVuZGVyT2Jqcy5jb250cm9scygpO1xuICAgICAgICBpZiAoY29udHJvbHMpIHtcbiAgICAgICAgICBjb250cm9scy5lbmFibGVkID0gZW5hYmxlO1xuICAgICAgICAgIC8vIHRyaWdnZXIgbW91c2V1cCBvbiByZS1lbmFibGUgdG8gcHJldmVudCBzdGlja3kgY29udHJvbHNcbiAgICAgICAgICBlbmFibGUgJiYgY29udHJvbHMuZG9tRWxlbWVudCAmJiBjb250cm9scy5kb21FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJykpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZU5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnRW5kOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZVJpZ2h0Q2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVIb3Zlcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0NsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25MaW5rUmlnaHRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0hvdmVyOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25CYWNrZ3JvdW5kQ2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkJhY2tncm91bmRSaWdodENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSwgbGlua2VkRkdQcm9wcyksIGxpbmtlZFJlbmRlck9ianNQcm9wcyksXG4gIG1ldGhvZHM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICB6b29tVG9GaXQ6IGZ1bmN0aW9uIHpvb21Ub0ZpdChzdGF0ZSwgdHJhbnNpdGlvbkR1cmF0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgX3N0YXRlJGZvcmNlR3JhcGg7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYmJveEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBiYm94QXJnc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBzdGF0ZS5yZW5kZXJPYmpzLmZpdFRvQmJveCgoX3N0YXRlJGZvcmNlR3JhcGggPSBzdGF0ZS5mb3JjZUdyYXBoKS5nZXRHcmFwaEJib3guYXBwbHkoX3N0YXRlJGZvcmNlR3JhcGgsIGJib3hBcmdzKSwgdHJhbnNpdGlvbkR1cmF0aW9uLCBwYWRkaW5nKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcGF1c2VBbmltYXRpb246IGZ1bmN0aW9uIHBhdXNlQW5pbWF0aW9uKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQpO1xuICAgICAgICBzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlc3VtZUFuaW1hdGlvbjogZnVuY3Rpb24gcmVzdW1lQW5pbWF0aW9uKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ3ljbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2FuaW1hdGlvbkN5Y2xlOiBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUoc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5lbmFibGVQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgICAgICAgLy8gcmVzZXQgY2FudmFzIGN1cnNvciAob3ZlcnJpZGUgZHJhZ0NvbnRyb2xzIGN1cnNvcilcbiAgICAgICAgdGhpcy5yZW5kZXJlcigpLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRnJhbWUgY3ljbGVcbiAgICAgIHN0YXRlLmZvcmNlR3JhcGgudGlja0ZyYW1lKCk7XG4gICAgICBzdGF0ZS5yZW5kZXJPYmpzLnRpY2soKTtcbiAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkN5Y2xlKTtcbiAgICB9LFxuICAgIHNjZW5lOiBmdW5jdGlvbiBzY2VuZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnJlbmRlck9ianMuc2NlbmUoKTtcbiAgICB9LFxuICAgIC8vIEV4cG9zZSBzY2VuZVxuICAgIGNhbWVyYTogZnVuY3Rpb24gY2FtZXJhKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUucmVuZGVyT2Jqcy5jYW1lcmEoKTtcbiAgICB9LFxuICAgIC8vIEV4cG9zZSBjYW1lcmFcbiAgICByZW5kZXJlcjogZnVuY3Rpb24gcmVuZGVyZXIoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5yZW5kZXJPYmpzLnJlbmRlcmVyKCk7XG4gICAgfSxcbiAgICAvLyBFeHBvc2UgcmVuZGVyZXJcbiAgICBjb250cm9sczogZnVuY3Rpb24gY29udHJvbHMoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5yZW5kZXJPYmpzLmNvbnRyb2xzKCk7XG4gICAgfSxcbiAgICAvLyBFeHBvc2UgY29udHJvbHNcbiAgICB0YkNvbnRyb2xzOiBmdW5jdGlvbiB0YkNvbnRyb2xzKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUucmVuZGVyT2Jqcy50YkNvbnRyb2xzKCk7XG4gICAgfSxcbiAgICAvLyBUbyBiZSBkZXByZWNhdGVkXG4gICAgX2Rlc3RydWN0b3I6IGZ1bmN0aW9uIF9kZXN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5ncmFwaERhdGEoe1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBsaW5rZWRGR01ldGhvZHMpLCBsaW5rZWRSZW5kZXJPYmpzTWV0aG9kcyksXG4gIHN0YXRlSW5pdDogZnVuY3Rpb24gc3RhdGVJbml0KF9yZWY1KSB7XG4gICAgdmFyIGNvbnRyb2xUeXBlID0gX3JlZjUuY29udHJvbFR5cGUsXG4gICAgICByZW5kZXJlckNvbmZpZyA9IF9yZWY1LnJlbmRlcmVyQ29uZmlnLFxuICAgICAgZXh0cmFSZW5kZXJlcnMgPSBfcmVmNS5leHRyYVJlbmRlcmVycztcbiAgICB2YXIgZm9yY2VHcmFwaCA9IG5ldyBUaHJlZUZvcmNlR3JhcGgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9yY2VHcmFwaDogZm9yY2VHcmFwaCxcbiAgICAgIHJlbmRlck9ianM6IFRocmVlUmVuZGVyT2JqZWN0cyh7XG4gICAgICAgIGNvbnRyb2xUeXBlOiBjb250cm9sVHlwZSxcbiAgICAgICAgcmVuZGVyZXJDb25maWc6IHJlbmRlcmVyQ29uZmlnLFxuICAgICAgICBleHRyYVJlbmRlcmVyczogZXh0cmFSZW5kZXJlcnNcbiAgICAgIH0pLm9iamVjdHMoW2ZvcmNlR3JhcGhdKSAvLyBQb3B1bGF0ZSBzY2VuZVxuICAgICAgLmxpZ2h0cyhbbmV3IHRocmVlLkFtYmllbnRMaWdodCgweGNjY2NjYywgTWF0aC5QSSksIG5ldyB0aHJlZS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjYgKiBNYXRoLlBJKV0pXG4gICAgfTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChkb21Ob2RlLCBzdGF0ZSkge1xuICAgIC8vIFdpcGUgRE9NXG4gICAgZG9tTm9kZS5pbm5lckhUTUwgPSAnJztcblxuICAgIC8vIEFkZCByZWxhdGl2ZSBjb250YWluZXJcbiAgICBkb21Ob2RlLmFwcGVuZENoaWxkKHN0YXRlLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBzdGF0ZS5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG4gICAgLy8gQWRkIHJlbmRlck9ianNcbiAgICB2YXIgcm9Eb21Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3RhdGUuY29udGFpbmVyLmFwcGVuZENoaWxkKHJvRG9tTm9kZSk7XG4gICAgc3RhdGUucmVuZGVyT2Jqcyhyb0RvbU5vZGUpO1xuICAgIHZhciBjYW1lcmEgPSBzdGF0ZS5yZW5kZXJPYmpzLmNhbWVyYSgpO1xuICAgIHZhciByZW5kZXJlciA9IHN0YXRlLnJlbmRlck9ianMucmVuZGVyZXIoKTtcbiAgICB2YXIgY29udHJvbHMgPSBzdGF0ZS5yZW5kZXJPYmpzLmNvbnRyb2xzKCk7XG4gICAgY29udHJvbHMuZW5hYmxlZCA9ICEhc3RhdGUuZW5hYmxlTmF2aWdhdGlvbkNvbnRyb2xzO1xuICAgIHN0YXRlLmxhc3RTZXRDYW1lcmFaID0gY2FtZXJhLnBvc2l0aW9uLno7XG5cbiAgICAvLyBBZGQgaW5mbyBzcGFjZVxuICAgIHZhciBpbmZvRWxlbTtcbiAgICBzdGF0ZS5jb250YWluZXIuYXBwZW5kQ2hpbGQoaW5mb0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgaW5mb0VsZW0uY2xhc3NOYW1lID0gJ2dyYXBoLWluZm8tbXNnJztcbiAgICBpbmZvRWxlbS50ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgLy8gY29uZmlnIGZvcmNlZ3JhcGhcbiAgICBzdGF0ZS5mb3JjZUdyYXBoLm9uTG9hZGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICBpbmZvRWxlbS50ZXh0Q29udGVudCA9ICdMb2FkaW5nLi4uJztcbiAgICB9KS5vbkZpbmlzaExvYWRpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgaW5mb0VsZW0udGV4dENvbnRlbnQgPSAnJztcbiAgICB9KS5vblVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzeW5jIGdyYXBoIGRhdGEgc3RydWN0dXJlc1xuICAgICAgc3RhdGUuZ3JhcGhEYXRhID0gc3RhdGUuZm9yY2VHcmFwaC5ncmFwaERhdGEoKTtcblxuICAgICAgLy8gcmUtYWltIGNhbWVyYSwgaWYgc3RpbGwgaW4gZGVmYXVsdCBwb3NpdGlvbiAobm90IHVzZXIgbW9kaWZpZWQpXG4gICAgICBpZiAoY2FtZXJhLnBvc2l0aW9uLnggPT09IDAgJiYgY2FtZXJhLnBvc2l0aW9uLnkgPT09IDAgJiYgY2FtZXJhLnBvc2l0aW9uLnogPT09IHN0YXRlLmxhc3RTZXRDYW1lcmFaICYmIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FtZXJhLmxvb2tBdChzdGF0ZS5mb3JjZUdyYXBoLnBvc2l0aW9uKTtcbiAgICAgICAgc3RhdGUubGFzdFNldENhbWVyYVogPSBjYW1lcmEucG9zaXRpb24ueiA9IE1hdGguY2JydChzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoKSAqIENBTUVSQV9ESVNUQU5DRTJOT0RFU19GQUNUT1I7XG4gICAgICB9XG4gICAgfSkub25GaW5pc2hVcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU2V0dXAgbm9kZSBkcmFnIGludGVyYWN0aW9uXG4gICAgICBpZiAoc3RhdGUuX2RyYWdDb250cm9scykge1xuICAgICAgICB2YXIgY3VyTm9kZURyYWcgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBub2RlLl9faW5pdGlhbEZpeGVkUG9zICYmICFub2RlLl9fZGlzcG9zZUNvbnRyb2xzQWZ0ZXJEcmFnO1xuICAgICAgICB9KTsgLy8gZGV0ZWN0IGlmIHRoZXJlJ3MgYSBub2RlIGJlaW5nIGRyYWdnZWQgdXNpbmcgdGhlIGV4aXN0aW5nIGRyYWcgY29udHJvbHNcbiAgICAgICAgaWYgKGN1ck5vZGVEcmFnKSB7XG4gICAgICAgICAgY3VyTm9kZURyYWcuX19kaXNwb3NlQ29udHJvbHNBZnRlckRyYWcgPSB0cnVlOyAvLyBwb3N0cG9uZSBwcmV2aW91cyBjb250cm9scyBkaXNwb3NhbCB1bnRpbCBkcmFnIGVuZHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5fZHJhZ0NvbnRyb2xzLmRpc3Bvc2UoKTsgLy8gY2FuY2VsIHByZXZpb3VzIGRyYWcgY29udHJvbHNcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5fZHJhZ0NvbnRyb2xzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVuYWJsZU5vZGVEcmFnICYmIHN0YXRlLmVuYWJsZVBvaW50ZXJJbnRlcmFjdGlvbiAmJiBzdGF0ZS5mb3JjZUVuZ2luZSA9PT0gJ2QzJykge1xuICAgICAgICAvLyBDYW4ndCBhY2Nlc3Mgbm9kZSBwb3NpdGlvbnMgcHJvZ3JhbW1hdGljYWxseSBpbiBuZ3JhcGhcbiAgICAgICAgdmFyIGRyYWdDb250cm9scyA9IHN0YXRlLl9kcmFnQ29udHJvbHMgPSBuZXcgRHJhZ0NvbnRyb2xzKHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5fX3RocmVlT2JqO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0pLCBjYW1lcmEsIHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgICBkcmFnQ29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlOyAvLyBEaXNhYmxlIGNvbnRyb2xzIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgICAgICAvLyB0cmFjayBkcmFnIG9iamVjdCBtb3ZlbWVudFxuICAgICAgICAgIGV2ZW50Lm9iamVjdC5fX2luaXRpYWxQb3MgPSBldmVudC5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICBldmVudC5vYmplY3QuX19wcmV2UG9zID0gZXZlbnQub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgdmFyIG5vZGUgPSBnZXRHcmFwaE9iaihldmVudC5vYmplY3QpLl9fZGF0YTtcbiAgICAgICAgICAhbm9kZS5fX2luaXRpYWxGaXhlZFBvcyAmJiAobm9kZS5fX2luaXRpYWxGaXhlZFBvcyA9IHtcbiAgICAgICAgICAgIGZ4OiBub2RlLmZ4LFxuICAgICAgICAgICAgZnk6IG5vZGUuZnksXG4gICAgICAgICAgICBmejogbm9kZS5melxuICAgICAgICAgIH0pO1xuICAgICAgICAgICFub2RlLl9faW5pdGlhbFBvcyAmJiAobm9kZS5fX2luaXRpYWxQb3MgPSB7XG4gICAgICAgICAgICB4OiBub2RlLngsXG4gICAgICAgICAgICB5OiBub2RlLnksXG4gICAgICAgICAgICB6OiBub2RlLnpcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGxvY2sgbm9kZVxuICAgICAgICAgIFsneCcsICd5JywgJ3onXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtcImZcIi5jb25jYXQoYyldID0gbm9kZVtjXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGRyYWcgY3Vyc29yXG4gICAgICAgICAgcmVuZGVyZXIuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdncmFiYmFibGUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRyYWdDb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGVPYmogPSBnZXRHcmFwaE9iaihldmVudC5vYmplY3QpO1xuICAgICAgICAgIGlmICghZXZlbnQub2JqZWN0Lmhhc093blByb3BlcnR5KCdfX2dyYXBoT2JqVHlwZScpKSB7XG4gICAgICAgICAgICAvLyBJZiBkcmFnZ2luZyBhIGNoaWxkIG9mIHRoZSBub2RlLCB1cGRhdGUgdGhlIG5vZGUgb2JqZWN0IGluc3RlYWRcbiAgICAgICAgICAgIHZhciBpbml0UG9zID0gZXZlbnQub2JqZWN0Ll9faW5pdGlhbFBvcztcbiAgICAgICAgICAgIHZhciBwcmV2UG9zID0gZXZlbnQub2JqZWN0Ll9fcHJldlBvcztcbiAgICAgICAgICAgIHZhciBfbmV3UG9zID0gZXZlbnQub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICAgICAgbm9kZU9iai5wb3NpdGlvbi5hZGQoX25ld1Bvcy5jbG9uZSgpLnN1YihwcmV2UG9zKSk7IC8vIHRyYW5zbGF0ZSBub2RlIG9iamVjdCBieSB0aGUgbW90aW9uIGRlbHRhXG4gICAgICAgICAgICBwcmV2UG9zLmNvcHkoX25ld1Bvcyk7XG4gICAgICAgICAgICBfbmV3UG9zLmNvcHkoaW5pdFBvcyk7IC8vIHJlc2V0IGNoaWxkIGJhY2sgdG8gaXRzIGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2RlT2JqLl9fZGF0YTtcbiAgICAgICAgICB2YXIgbmV3UG9zID0gbm9kZU9iai5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICAgICAgeDogbmV3UG9zLnggLSBub2RlLngsXG4gICAgICAgICAgICB5OiBuZXdQb3MueSAtIG5vZGUueSxcbiAgICAgICAgICAgIHo6IG5ld1Bvcy56IC0gbm9kZS56XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBNb3ZlIGZ4L2Z5L2Z6IChhbmQgeC95L3opIG9mIG5vZGVzIGJhc2VkIG9uIG9iamVjdCBuZXcgcG9zaXRpb25cbiAgICAgICAgICBbJ3gnLCAneScsICd6J10uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVbXCJmXCIuY29uY2F0KGMpXSA9IG5vZGVbY10gPSBuZXdQb3NbY107XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdGUuZm9yY2VHcmFwaC5kM0FscGhhVGFyZ2V0KDAuMykgLy8ga2VlcCBlbmdpbmUgcnVubmluZyBhdCBsb3cgaW50ZW5zaXR5IHRocm91Z2hvdXQgZHJhZ1xuICAgICAgICAgIC5yZXNldENvdW50ZG93bigpOyAvLyBwcmV2ZW50IGZyZWV6ZSB3aGlsZSBkcmFnZ2luZ1xuXG4gICAgICAgICAgbm9kZS5fX2RyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLm9uTm9kZURyYWcobm9kZSwgdHJhbnNsYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRyYWdDb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50Lm9iamVjdC5fX2luaXRpYWxQb3M7IC8vIHJlbW92ZSB0cmFja2luZyBhdHRyaWJ1dGVzXG4gICAgICAgICAgZGVsZXRlIGV2ZW50Lm9iamVjdC5fX3ByZXZQb3M7XG4gICAgICAgICAgdmFyIG5vZGUgPSBnZXRHcmFwaE9iaihldmVudC5vYmplY3QpLl9fZGF0YTtcblxuICAgICAgICAgIC8vIGRpc3Bvc2UgcHJldmlvdXMgY29udHJvbHMgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKG5vZGUuX19kaXNwb3NlQ29udHJvbHNBZnRlckRyYWcpIHtcbiAgICAgICAgICAgIGRyYWdDb250cm9scy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5fX2Rpc3Bvc2VDb250cm9sc0FmdGVyRHJhZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluaXRGaXhlZFBvcyA9IG5vZGUuX19pbml0aWFsRml4ZWRQb3M7XG4gICAgICAgICAgdmFyIGluaXRQb3MgPSBub2RlLl9faW5pdGlhbFBvcztcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICAgICAgeDogaW5pdFBvcy54IC0gbm9kZS54LFxuICAgICAgICAgICAgeTogaW5pdFBvcy55IC0gbm9kZS55LFxuICAgICAgICAgICAgejogaW5pdFBvcy56IC0gbm9kZS56XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaW5pdEZpeGVkUG9zKSB7XG4gICAgICAgICAgICBbJ3gnLCAneScsICd6J10uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICB2YXIgZmMgPSBcImZcIi5jb25jYXQoYyk7XG4gICAgICAgICAgICAgIGlmIChpbml0Rml4ZWRQb3NbZmNdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtmY107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUuX19pbml0aWFsRml4ZWRQb3M7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5fX2luaXRpYWxQb3M7XG4gICAgICAgICAgICBpZiAobm9kZS5fX2RyYWdnZWQpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuX19kcmFnZ2VkO1xuICAgICAgICAgICAgICBzdGF0ZS5vbk5vZGVEcmFnRW5kKG5vZGUsIHRyYW5zbGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZDNBbHBoYVRhcmdldCgwKSAvLyByZWxlYXNlIGVuZ2luZSBsb3cgaW50ZW5zaXR5XG4gICAgICAgICAgLnJlc2V0Q291bnRkb3duKCk7IC8vIGxldCB0aGUgZW5naW5lIHJlYWRqdXN0IGFmdGVyIHJlbGVhc2luZyBmaXhlZCBub2Rlc1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmVuYWJsZU5hdmlnYXRpb25Db250cm9scykge1xuICAgICAgICAgICAgY29udHJvbHMuZW5hYmxlZCA9IHRydWU7IC8vIFJlLWVuYWJsZSBjb250cm9sc1xuICAgICAgICAgICAgY29udHJvbHMuZG9tRWxlbWVudCAmJiBjb250cm9scy5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQgJiYgY29udHJvbHMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAvLyBzaW11bGF0ZSBtb3VzZXVwIHRvIGVuc3VyZSB0aGUgY29udHJvbHMgZG9uJ3QgdGFrZSBvdmVyIGFmdGVyIGRyYWdlbmRcbiAgICAgICAgICAgIG5ldyBQb2ludGVyRXZlbnQoJ3BvaW50ZXJ1cCcsIHtcbiAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICd0b3VjaCdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjbGVhciBjdXJzb3JcbiAgICAgICAgICByZW5kZXJlci5kb21FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2dyYWJiYWJsZScpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNvbmZpZyByZW5kZXJPYmpzXG4gICAgdGhyZWUuUkVWSVNJT04gPCAxNTUgJiYgKHN0YXRlLnJlbmRlck9ianMucmVuZGVyZXIoKS51c2VMZWdhY3lMaWdodHMgPSBmYWxzZSk7IC8vIGZvcmNlIGJlaGF2aW9yIGZvciB0aHJlZSA8IDE1NVxuICAgIHN0YXRlLnJlbmRlck9ianMuaG92ZXJPcmRlckNvbXBhcmF0b3IoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIFByaW9yaXRpemUgZ3JhcGggb2JqZWN0c1xuICAgICAgdmFyIGFPYmogPSBnZXRHcmFwaE9iaihhKTtcbiAgICAgIGlmICghYU9iaikgcmV0dXJuIDE7XG4gICAgICB2YXIgYk9iaiA9IGdldEdyYXBoT2JqKGIpO1xuICAgICAgaWYgKCFiT2JqKSByZXR1cm4gLTE7XG5cbiAgICAgIC8vIFByaW9yaXRpemUgbm9kZXMgb3ZlciBsaW5rc1xuICAgICAgdmFyIGlzTm9kZSA9IGZ1bmN0aW9uIGlzTm9kZShvKSB7XG4gICAgICAgIHJldHVybiBvLl9fZ3JhcGhPYmpUeXBlID09PSAnbm9kZSc7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlzTm9kZShiT2JqKSAtIGlzTm9kZShhT2JqKTtcbiAgICB9KS50b29sdGlwQ29udGVudChmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIgZ3JhcGhPYmogPSBnZXRHcmFwaE9iaihvYmopO1xuICAgICAgcmV0dXJuIGdyYXBoT2JqID8gYWNjZXNzb3JGbihzdGF0ZVtcIlwiLmNvbmNhdChncmFwaE9iai5fX2dyYXBoT2JqVHlwZSwgXCJMYWJlbFwiKV0pKGdyYXBoT2JqLl9fZGF0YSkgfHwgJycgOiAnJztcbiAgICB9KS5ob3ZlckR1cmluZ0RyYWcoZmFsc2UpLm9uSG92ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgLy8gVXBkYXRlIHRvb2x0aXAgYW5kIHRyaWdnZXIgb25Ib3ZlciBldmVudHNcbiAgICAgIHZhciBob3Zlck9iaiA9IGdldEdyYXBoT2JqKG9iaik7XG4gICAgICBpZiAoaG92ZXJPYmogIT09IHN0YXRlLmhvdmVyT2JqKSB7XG4gICAgICAgIHZhciBwcmV2T2JqVHlwZSA9IHN0YXRlLmhvdmVyT2JqID8gc3RhdGUuaG92ZXJPYmouX19ncmFwaE9ialR5cGUgOiBudWxsO1xuICAgICAgICB2YXIgcHJldk9iakRhdGEgPSBzdGF0ZS5ob3Zlck9iaiA/IHN0YXRlLmhvdmVyT2JqLl9fZGF0YSA6IG51bGw7XG4gICAgICAgIHZhciBvYmpUeXBlID0gaG92ZXJPYmogPyBob3Zlck9iai5fX2dyYXBoT2JqVHlwZSA6IG51bGw7XG4gICAgICAgIHZhciBvYmpEYXRhID0gaG92ZXJPYmogPyBob3Zlck9iai5fX2RhdGEgOiBudWxsO1xuICAgICAgICBpZiAocHJldk9ialR5cGUgJiYgcHJldk9ialR5cGUgIT09IG9ialR5cGUpIHtcbiAgICAgICAgICAvLyBIb3ZlciBvdXRcbiAgICAgICAgICB2YXIgZm4gPSBzdGF0ZVtcIm9uXCIuY29uY2F0KHByZXZPYmpUeXBlID09PSAnbm9kZScgPyAnTm9kZScgOiAnTGluaycsIFwiSG92ZXJcIildO1xuICAgICAgICAgIGZuICYmIGZuKG51bGwsIHByZXZPYmpEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqVHlwZSkge1xuICAgICAgICAgIC8vIEhvdmVyIGluXG4gICAgICAgICAgdmFyIF9mbiA9IHN0YXRlW1wib25cIi5jb25jYXQob2JqVHlwZSA9PT0gJ25vZGUnID8gJ05vZGUnIDogJ0xpbmsnLCBcIkhvdmVyXCIpXTtcbiAgICAgICAgICBfZm4gJiYgX2ZuKG9iakRhdGEsIHByZXZPYmpUeXBlID09PSBvYmpUeXBlID8gcHJldk9iakRhdGEgOiBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBwb2ludGVyIGlmIGhvdmVyZWQgb2JqZWN0IGlzIGNsaWNrYWJsZVxuICAgICAgICByZW5kZXJlci5kb21FbGVtZW50LmNsYXNzTGlzdFtob3Zlck9iaiAmJiBzdGF0ZVtcIm9uXCIuY29uY2F0KG9ialR5cGUgPT09ICdub2RlJyA/ICdOb2RlJyA6ICdMaW5rJywgXCJDbGlja1wiKV0gfHwgIWhvdmVyT2JqICYmIHN0YXRlLm9uQmFja2dyb3VuZENsaWNrID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ2NsaWNrYWJsZScpO1xuICAgICAgICBzdGF0ZS5ob3Zlck9iaiA9IGhvdmVyT2JqO1xuICAgICAgfVxuICAgIH0pLmNsaWNrQWZ0ZXJEcmFnKGZhbHNlKS5vbkNsaWNrKGZ1bmN0aW9uIChvYmosIGV2KSB7XG4gICAgICB2YXIgZ3JhcGhPYmogPSBnZXRHcmFwaE9iaihvYmopO1xuICAgICAgaWYgKGdyYXBoT2JqKSB7XG4gICAgICAgIHZhciBmbiA9IHN0YXRlW1wib25cIi5jb25jYXQoZ3JhcGhPYmouX19ncmFwaE9ialR5cGUgPT09ICdub2RlJyA/ICdOb2RlJyA6ICdMaW5rJywgXCJDbGlja1wiKV07XG4gICAgICAgIGZuICYmIGZuKGdyYXBoT2JqLl9fZGF0YSwgZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2soZXYpO1xuICAgICAgfVxuICAgIH0pLm9uUmlnaHRDbGljayhmdW5jdGlvbiAob2JqLCBldikge1xuICAgICAgLy8gSGFuZGxlIHJpZ2h0LWNsaWNrIGV2ZW50c1xuICAgICAgdmFyIGdyYXBoT2JqID0gZ2V0R3JhcGhPYmoob2JqKTtcbiAgICAgIGlmIChncmFwaE9iaikge1xuICAgICAgICB2YXIgZm4gPSBzdGF0ZVtcIm9uXCIuY29uY2F0KGdyYXBoT2JqLl9fZ3JhcGhPYmpUeXBlID09PSAnbm9kZScgPyAnTm9kZScgOiAnTGluaycsIFwiUmlnaHRDbGlja1wiKV07XG4gICAgICAgIGZuICYmIGZuKGdyYXBoT2JqLl9fZGF0YSwgZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUub25CYWNrZ3JvdW5kUmlnaHRDbGljayAmJiBzdGF0ZS5vbkJhY2tncm91bmRSaWdodENsaWNrKGV2KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vXG5cbiAgICAvLyBLaWNrLW9mZiByZW5kZXJlclxuICAgIHRoaXMuX2FuaW1hdGlvbkN5Y2xlKCk7XG4gIH1cbn0pO1xuXG4vL1xuXG5mdW5jdGlvbiBnZXRHcmFwaE9iaihvYmplY3QpIHtcbiAgdmFyIG9iaiA9IG9iamVjdDtcbiAgLy8gcmVjdXJzZSB1cCBvYmplY3QgY2hhaW4gdW50aWwgZmluZGluZyB0aGUgZ3JhcGggb2JqZWN0XG4gIHdoaWxlIChvYmogJiYgIW9iai5oYXNPd25Qcm9wZXJ0eSgnX19ncmFwaE9ialR5cGUnKSkge1xuICAgIG9iaiA9IG9iai5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IHsgXzNkRm9yY2VHcmFwaCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/3d-force-graph@1.73.3/node_modules/3d-force-graph/dist/3d-force-graph.mjs\n");

/***/ })

};
;