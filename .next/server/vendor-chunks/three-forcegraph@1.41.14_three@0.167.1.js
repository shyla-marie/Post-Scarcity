"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-forcegraph@1.41.14_three@0.167.1";
exports.ids = ["vendor-chunks/three-forcegraph@1.41.14_three@0.167.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/three-forcegraph@1.41.14_three@0.167.1/node_modules/three-forcegraph/dist/three-forcegraph.mjs":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/three-forcegraph@1.41.14_three@0.167.1/node_modules/three-forcegraph/dist/three-forcegraph.mjs ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ threeForcegraph)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.167.1/node_modules/three/build/three.module.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var ngraph_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ngraph.graph */ \"(ssr)/./node_modules/.pnpm/ngraph.graph@20.0.1/node_modules/ngraph.graph/index.js\");\n/* harmony import */ var ngraph_forcelayout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ngraph.forcelayout */ \"(ssr)/./node_modules/.pnpm/ngraph.forcelayout@3.3.1/node_modules/ngraph.forcelayout/index.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/.pnpm/kapsule@1.14.5/node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/.pnpm/accessor-fn@1.5.1/node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js\");\n/* harmony import */ var data_joint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! data-joint */ \"(ssr)/./node_modules/.pnpm/data-joint@1.3.1/node_modules/data-joint/dist/data-joint.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tinycolor2 */ \"(ssr)/./node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/esm/tinycolor.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && _setPrototypeOf(p, r.prototype), p;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar materialDispose = function materialDispose(material) {\n  if (material instanceof Array) {\n    material.forEach(materialDispose);\n  } else {\n    if (material.map) {\n      material.map.dispose();\n    }\n    material.dispose();\n  }\n};\nvar deallocate = function deallocate(obj) {\n  if (obj.geometry) {\n    obj.geometry.dispose();\n  }\n  if (obj.material) {\n    materialDispose(obj.material);\n  }\n  if (obj.texture) {\n    obj.texture.dispose();\n  }\n  if (obj.children) {\n    obj.children.forEach(deallocate);\n  }\n};\nvar emptyObject = function emptyObject(obj) {\n  while (obj.children.length) {\n    var childObj = obj.children[0];\n    obj.remove(childObj);\n    deallocate(childObj);\n  }\n};\n\nvar _excluded = [\"objFilter\"];\nfunction threeDigest(data, scene) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$objFilter = _ref.objFilter,\n    objFilter = _ref$objFilter === void 0 ? function () {\n      return true;\n    } : _ref$objFilter,\n    options = _objectWithoutProperties(_ref, _excluded);\n  return (0,data_joint__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(data, scene.children.filter(objFilter), function (obj) {\n    return scene.add(obj);\n  }, function (obj) {\n    scene.remove(obj);\n    emptyObject(obj);\n  }, _objectSpread2({\n    objBindAttr: '__threeObj'\n  }, options));\n}\n\nvar colorStr2Hex = function colorStr2Hex(str) {\n  return isNaN(str) ? parseInt((0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(str).toHex(), 16) : str;\n};\nvar colorAlpha = function colorAlpha(str) {\n  return isNaN(str) ? (0,tinycolor2__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(str).getAlpha() : 1;\n};\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === void 0 ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === void 0 ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\nvar three$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Group: three__WEBPACK_IMPORTED_MODULE_7__.Group,\n  Mesh: three__WEBPACK_IMPORTED_MODULE_7__.Mesh,\n  MeshLambertMaterial: three__WEBPACK_IMPORTED_MODULE_7__.MeshLambertMaterial,\n  Color: three__WEBPACK_IMPORTED_MODULE_7__.Color,\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_7__.BufferGeometry,\n  BufferAttribute: three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute,\n  Matrix4: three__WEBPACK_IMPORTED_MODULE_7__.Matrix4,\n  Vector3: three__WEBPACK_IMPORTED_MODULE_7__.Vector3,\n  SphereGeometry: three__WEBPACK_IMPORTED_MODULE_7__.SphereGeometry,\n  CylinderGeometry: three__WEBPACK_IMPORTED_MODULE_7__.CylinderGeometry,\n  TubeGeometry: three__WEBPACK_IMPORTED_MODULE_7__.TubeGeometry,\n  ConeGeometry: three__WEBPACK_IMPORTED_MODULE_7__.ConeGeometry,\n  Line: three__WEBPACK_IMPORTED_MODULE_7__.Line,\n  LineBasicMaterial: three__WEBPACK_IMPORTED_MODULE_7__.LineBasicMaterial,\n  QuadraticBezierCurve3: three__WEBPACK_IMPORTED_MODULE_7__.QuadraticBezierCurve3,\n  CubicBezierCurve3: three__WEBPACK_IMPORTED_MODULE_7__.CubicBezierCurve3,\n  Box3: three__WEBPACK_IMPORTED_MODULE_7__.Box3\n};\nvar ngraph = {\n  graph: ngraph_graph__WEBPACK_IMPORTED_MODULE_0__,\n  forcelayout: ngraph_forcelayout__WEBPACK_IMPORTED_MODULE_1__\n};\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// support multiple method names for backwards threejs compatibility\nvar setAttributeFn = new three$1.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar applyMatrix4Fn = new three$1.BufferGeometry().applyMatrix4 ? 'applyMatrix4' : 'applyMatrix';\nvar ForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n  props: {\n    jsonUrl: {\n      onChange: function onChange(jsonUrl, state) {\n        var _this = this;\n        if (jsonUrl && !state.fetchingJson) {\n          // Load data asynchronously\n          state.fetchingJson = true;\n          state.onLoading();\n          fetch(jsonUrl).then(function (r) {\n            return r.json();\n          }).then(function (json) {\n            state.fetchingJson = false;\n            state.onFinishLoading(json);\n            _this.graphData(json);\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(graphData, state) {\n        state.engineRunning = false; // Pause simulation immediately\n      }\n    },\n    numDimensions: {\n      \"default\": 3,\n      onChange: function onChange(numDim, state) {\n        var chargeForce = state.d3ForceLayout.force('charge');\n        // Increase repulsion on 3D mode for improved spatial separation\n        if (chargeForce) {\n          chargeForce.strength(numDim > 2 ? -60 : -30);\n        }\n        if (numDim < 3) {\n          eraseDimension(state.graphData.nodes, 'z');\n        }\n        if (numDim < 2) {\n          eraseDimension(state.graphData.nodes, 'y');\n        }\n        function eraseDimension(nodes, dim) {\n          nodes.forEach(function (d) {\n            delete d[dim]; // position\n            delete d[\"v\".concat(dim)]; // velocity\n          });\n        }\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, zin, zout, radialin, radialout\n        !dagMode && state.forceEngine === 'd3' && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = n.fz = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4\n    },\n    // volume per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val'\n    },\n    nodeResolution: {\n      \"default\": 8\n    },\n    // how many slice segments in the sphere's circumference\n    nodeColor: {\n      \"default\": 'color'\n    },\n    nodeAutoColorBy: {},\n    nodeOpacity: {\n      \"default\": 0.75\n    },\n    nodeVisibility: {\n      \"default\": true\n    },\n    nodeThreeObject: {},\n    nodeThreeObjectExtend: {\n      \"default\": false\n    },\n    nodePositionUpdate: {\n      triggerUpdate: false\n    },\n    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true\n    },\n    linkColor: {\n      \"default\": 'color'\n    },\n    linkAutoColorBy: {},\n    linkOpacity: {\n      \"default\": 0.2\n    },\n    linkWidth: {},\n    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.\n    linkResolution: {\n      \"default\": 6\n    },\n    // how many radial segments in each line tube's geometry\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // line curvature radius (0: straight, 1: semi-circle)\n    linkCurveRotation: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)\n    linkMaterial: {},\n    linkThreeObject: {},\n    linkThreeObjectExtend: {\n      \"default\": false\n    },\n    linkPositionUpdate: {\n      triggerUpdate: false\n    },\n    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.\n    linkDirectionalArrowLength: {\n      \"default\": 0\n    },\n    linkDirectionalArrowColor: {},\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: {\n      \"default\": 8\n    },\n    // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: {\n      \"default\": 0\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \"default\": 0.5\n    },\n    linkDirectionalParticleColor: {},\n    linkDirectionalParticleResolution: {\n      \"default\": 4\n    },\n    // how many slice segments in the particle sphere's circumference\n    forceEngine: {\n      \"default\": 'd3'\n    },\n    // d3 or ngraph\n    d3AlphaMin: {\n      \"default\": 0\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.d3ForceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.d3ForceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.d3ForceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    ngraphPhysics: {\n      \"default\": {\n        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js\n        timeStep: 20,\n        gravity: -1.2,\n        theta: 0.8,\n        springLength: 30,\n        springCoefficient: 0.0008,\n        dragCoefficient: 0.02\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onLoading: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishLoading: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    refresh: function refresh(state) {\n      state._flushObjects = true;\n      state._rerender();\n      return this;\n    },\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.d3ForceLayout.force(forceName); // Force getter\n      }\n      state.d3ForceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.d3ForceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    tickFrame: function tickFrame(state) {\n      var isD3Sim = state.forceEngine !== 'ngraph';\n      if (state.engineRunning) {\n        layoutTick();\n      }\n      updateArrows();\n      updatePhotons();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin) {\n          state.engineRunning = false; // Stop ticking graph\n          state.onEngineStop();\n        } else {\n          state.layout[isD3Sim ? 'tick' : 'step'](); // Tick it\n          state.onEngineTick();\n        }\n        var nodeThreeObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeThreeObjectExtend);\n\n        // Update nodes position\n        state.graphData.nodes.forEach(function (node) {\n          var obj = node.__threeObj;\n          if (!obj) return;\n          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);\n          var extendedObj = nodeThreeObjectExtendAccessor(node);\n          if (!state.nodePositionUpdate || !state.nodePositionUpdate(extendedObj ? obj.children[0] : obj, {\n            x: pos.x,\n            y: pos.y,\n            z: pos.z\n          }, node) // pass child custom object if extending the default\n          || extendedObj) {\n            obj.position.x = pos.x;\n            obj.position.y = pos.y || 0;\n            obj.position.z = pos.z || 0;\n          }\n        });\n\n        // Update links position\n        var linkWidthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var linkCurvatureAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var linkCurveRotationAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurveRotation);\n        var linkThreeObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkThreeObjectExtend);\n        state.graphData.links.forEach(function (link) {\n          var lineObj = link.__lineObj;\n          if (!lineObj) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          calcLinkCurve(link); // calculate link curve for all links, including custom replaced, so it can be used in directional functionality\n\n          var extendedObj = linkThreeObjectExtendAccessor(link);\n          if (state.linkPositionUpdate && state.linkPositionUpdate(extendedObj ? lineObj.children[1] : lineObj,\n          // pass child custom object if extending the default\n          {\n            start: {\n              x: start.x,\n              y: start.y,\n              z: start.z\n            },\n            end: {\n              x: end.x,\n              y: end.y,\n              z: end.z\n            }\n          }, link) && !extendedObj) {\n            // exit if successfully custom updated position of non-extended obj\n            return;\n          }\n          var curveResolution = 30; // # line segments\n          var curve = link.__curve;\n\n          // select default line obj if it's an extended group\n          var line = lineObj.children.length ? lineObj.children[0] : lineObj;\n          if (line.type === 'Line') {\n            // Update line geometry\n            if (!curve) {\n              // straight line\n              var linePos = line.geometry.getAttribute('position');\n              if (!linePos || !linePos.array || linePos.array.length !== 6) {\n                line.geometry[setAttributeFn]('position', linePos = new three$1.BufferAttribute(new Float32Array(2 * 3), 3));\n              }\n              linePos.array[0] = start.x;\n              linePos.array[1] = start.y || 0;\n              linePos.array[2] = start.z || 0;\n              linePos.array[3] = end.x;\n              linePos.array[4] = end.y || 0;\n              linePos.array[5] = end.z || 0;\n              linePos.needsUpdate = true;\n            } else {\n              // bezier curve line\n              line.geometry.setFromPoints(curve.getPoints(curveResolution));\n            }\n            line.geometry.computeBoundingSphere();\n          } else if (line.type === 'Mesh') {\n            // Update cylinder geometry\n\n            if (!curve) {\n              // straight tube\n              if (!line.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {\n                var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n                var r = linkWidth / 2;\n                var geometry = new three$1.CylinderGeometry(r, r, 1, state.linkResolution, 1, false);\n                geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));\n                geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));\n                line.geometry.dispose();\n                line.geometry = geometry;\n              }\n              var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);\n              var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);\n              var distance = vStart.distanceTo(vEnd);\n              line.position.x = vStart.x;\n              line.position.y = vStart.y;\n              line.position.z = vStart.z;\n              line.scale.z = distance;\n              line.parent.localToWorld(vEnd); // lookAt requires world coords\n              line.lookAt(vEnd);\n            } else {\n              // curved tube\n              if (!line.geometry.type.match(/^Tube(Buffer)?Geometry$/)) {\n                // reset object positioning\n                line.position.set(0, 0, 0);\n                line.rotation.set(0, 0, 0);\n                line.scale.set(1, 1, 1);\n              }\n              var _linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;\n              var _r = _linkWidth / 2;\n              var _geometry = new three$1.TubeGeometry(curve, curveResolution, _r, state.linkResolution, false);\n              line.geometry.dispose();\n              line.geometry = _geometry;\n            }\n          }\n        });\n\n        //\n\n        function calcLinkCurve(link) {\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var curvature = linkCurvatureAccessor(link);\n          if (!curvature) {\n            link.__curve = null; // Straight line\n          } else {\n            // bezier curve line (only for line types)\n            var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);\n            var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);\n            var l = vStart.distanceTo(vEnd); // line length\n\n            var curve;\n            var curveRotation = linkCurveRotationAccessor(link);\n            if (l > 0) {\n              var dx = end.x - start.x;\n              var dy = end.y - start.y || 0;\n              var vLine = new three$1.Vector3().subVectors(vEnd, vStart);\n              var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three$1.Vector3(0, 0, 1) : new three$1.Vector3(0, 1, 0)) // avoid cross-product of parallel vectors (prefer Z, fallback to Y)\n              .applyAxisAngle(vLine.normalize(), curveRotation) // rotate along line axis according to linkCurveRotation\n              .add(new three$1.Vector3().addVectors(vStart, vEnd).divideScalar(2));\n              curve = new three$1.QuadraticBezierCurve3(vStart, cp, vEnd);\n            } else {\n              // Same point, draw a loop\n              var d = curvature * 70;\n              var endAngle = -curveRotation; // Rotate clockwise (from Z angle perspective)\n              var startAngle = endAngle + Math.PI / 2;\n              curve = new three$1.CubicBezierCurve3(vStart, new three$1.Vector3(d * Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new three$1.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), 0).add(vStart), vEnd);\n            }\n            link.__curve = curve;\n          }\n        }\n      }\n      function updateArrows() {\n        // update link arrow position\n        var arrowRelPosAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var arrowLengthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var nodeValAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        state.graphData.links.forEach(function (link) {\n          var arrowObj = link.__arrowObj;\n          if (!arrowObj) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.cbrt(Math.max(0, nodeValAccessor(start) || 1)) * state.nodeRelSize;\n          var endR = Math.cbrt(Math.max(0, nodeValAccessor(end) || 1)) * state.nodeRelSize;\n          var arrowLength = arrowLengthAccessor(link);\n          var arrowRelPos = arrowRelPosAccessor(link);\n          var getPosAlongLine = link.__curve ? function (t) {\n            return link.__curve.getPoint(t);\n          } // interpolate along bezier curve\n          : function (t) {\n            // straight line: interpolate linearly\n            var iplt = function iplt(dim, start, end, t) {\n              return start[dim] + (end[dim] - start[dim]) * t || 0;\n            };\n            return {\n              x: iplt('x', start, end, t),\n              y: iplt('y', start, end, t),\n              z: iplt('z', start, end, t)\n            };\n          };\n          var lineLen = link.__curve ? link.__curve.getLength() : Math.sqrt(['x', 'y', 'z'].map(function (dim) {\n            return Math.pow((end[dim] || 0) - (start[dim] || 0), 2);\n          }).reduce(function (acc, v) {\n            return acc + v;\n          }, 0));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getPosAlongLine(posAlongLine / lineLen);\n          var arrowTail = getPosAlongLine((posAlongLine - arrowLength) / lineLen);\n          ['x', 'y', 'z'].forEach(function (dim) {\n            return arrowObj.position[dim] = arrowTail[dim];\n          });\n          var headVec = _construct(three$1.Vector3, _toConsumableArray(['x', 'y', 'z'].map(function (c) {\n            return arrowHead[c];\n          })));\n          arrowObj.parent.localToWorld(headVec); // lookAt requires world coords\n          arrowObj.lookAt(headVec);\n        });\n      }\n      function updatePhotons() {\n        // update link particle positions\n        var particleSpeedAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        state.graphData.links.forEach(function (link) {\n          var cyclePhotons = link.__photonsObj && link.__photonsObj.children;\n          var singleHopPhotons = link.__singleHopPhotonsObj && link.__singleHopPhotonsObj.children;\n          if ((!singleHopPhotons || !singleHopPhotons.length) && (!cyclePhotons || !cyclePhotons.length)) return;\n          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);\n          var start = pos[isD3Sim ? 'source' : 'from'];\n          var end = pos[isD3Sim ? 'target' : 'to'];\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = particleSpeedAccessor(link);\n          var getPhotonPos = link.__curve ? function (t) {\n            return link.__curve.getPoint(t);\n          } // interpolate along bezier curve\n          : function (t) {\n            // straight line: interpolate linearly\n            var iplt = function iplt(dim, start, end, t) {\n              return start[dim] + (end[dim] - start[dim]) * t || 0;\n            };\n            return {\n              x: iplt('x', start, end, t),\n              y: iplt('y', start, end, t),\n              z: iplt('z', start, end, t)\n            };\n          };\n          var photons = [].concat(_toConsumableArray(cyclePhotons || []), _toConsumableArray(singleHopPhotons || []));\n          photons.forEach(function (photon, idx) {\n            var singleHop = photon.parent.__linkThreeObjType === 'singleHopPhotons';\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : idx / cyclePhotons.length;\n            }\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                // remove particle\n                photon.parent.remove(photon);\n                emptyObject(photon);\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var pos = getPhotonPos(photonPosRatio);\n            ['x', 'y', 'z'].forEach(function (dim) {\n              return photon.position[dim] = pos[dim];\n            });\n          });\n        });\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link && state.graphData.links.includes(link)) {\n        if (!link.__singleHopPhotonsObj) {\n          var obj = new three$1.Group();\n          obj.__linkThreeObjType = 'singleHopPhotons';\n          link.__singleHopPhotonsObj = obj;\n          state.graphScene.add(obj);\n        }\n        var particleWidthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;\n        var numSegments = state.linkDirectionalParticleResolution;\n        var particleGeometry = new three$1.SphereGeometry(photonR, numSegments, numSegments);\n        var linkColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var particleColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor);\n        var photonColor = particleColorAccessor(link) || linkColorAccessor(link) || '#f0f0f0';\n        var materialColor = new three$1.Color(colorStr2Hex(photonColor));\n        var opacity = state.linkOpacity * 3;\n        var particleMaterial = new three$1.MeshLambertMaterial({\n          color: materialColor,\n          transparent: true,\n          opacity: opacity\n        });\n\n        // add a single hop particle\n        link.__singleHopPhotonsObj.add(new three$1.Mesh(particleGeometry, particleMaterial));\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      if (!state.initialised) return null;\n\n      // recursively collect all nested geometries bboxes\n      var bboxes = function getBboxes(obj) {\n        var bboxes = [];\n        if (obj.geometry) {\n          obj.geometry.computeBoundingBox();\n          var box = new three$1.Box3();\n          box.copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);\n          bboxes.push(box);\n        }\n        return bboxes.concat.apply(bboxes, _toConsumableArray((obj.children || []).filter(function (obj) {\n          return !obj.hasOwnProperty('__graphObjType') || obj.__graphObjType === 'node' && nodeFilter(obj.__data);\n        } // exclude filtered out nodes\n        ).map(getBboxes)));\n      }(state.graphScene);\n      if (!bboxes.length) return null;\n\n      // extract global x,y,z min/max\n      return Object.assign.apply(Object, _toConsumableArray(['x', 'y', 'z'].map(function (c) {\n        return _defineProperty({}, c, [(0,d3_array__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(bboxes, function (bb) {\n          return bb.min[c];\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(bboxes, function (bb) {\n          return bb.max[c];\n        })]);\n      })));\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      d3ForceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_14__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(threeObj, state) {\n    // Main three object to manipulate\n    state.graphScene = threeObj;\n  },\n  update: function update(state, changedProps) {\n    var hasAnyPropChanged = function hasAnyPropChanged(propList) {\n      return propList.some(function (p) {\n        return changedProps.hasOwnProperty(p);\n      });\n    };\n    state.engineRunning = false; // pause simulation\n    state.onUpdate();\n    if (state.nodeAutoColorBy !== null && hasAnyPropChanged(['nodeAutoColorBy', 'graphData', 'nodeColor'])) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null && hasAnyPropChanged(['linkAutoColorBy', 'graphData', 'linkColor'])) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // Digest nodes WebGL objects\n    if (state._flushObjects || hasAnyPropChanged(['graphData', 'nodeThreeObject', 'nodeThreeObjectExtend', 'nodeVal', 'nodeColor', 'nodeVisibility', 'nodeRelSize', 'nodeResolution', 'nodeOpacity'])) {\n      var customObjectAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeThreeObject);\n      var customObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeThreeObjectExtend);\n      var valAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var colorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n      var visibilityAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n      var sphereGeometries = {}; // indexed by node value\n      var sphereMaterials = {}; // indexed by color\n\n      threeDigest(state.graphData.nodes.filter(visibilityAccessor), state.graphScene, {\n        purge: state._flushObjects || hasAnyPropChanged([\n        // recreate objects if any of these props have changed\n        'nodeThreeObject', 'nodeThreeObjectExtend']),\n        objFilter: function objFilter(obj) {\n          return obj.__graphObjType === 'node';\n        },\n        createObj: function createObj(node) {\n          var customObj = customObjectAccessor(node);\n          var extendObj = customObjectExtendAccessor(node);\n          if (customObj && state.nodeThreeObject === customObj) {\n            // clone object if it's a shared object among all nodes\n            customObj = customObj.clone();\n          }\n          var obj;\n          if (customObj && !extendObj) {\n            obj = customObj;\n          } else {\n            // Add default object (sphere mesh)\n            obj = new three$1.Mesh();\n            obj.__graphDefaultObj = true;\n            if (customObj && extendObj) {\n              obj.add(customObj); // extend default with custom\n            }\n          }\n          obj.__graphObjType = 'node'; // Add object type\n\n          return obj;\n        },\n        updateObj: function updateObj(obj, node) {\n          if (obj.__graphDefaultObj) {\n            // bypass internal updates for custom node objects\n            var val = valAccessor(node) || 1;\n            var radius = Math.cbrt(val) * state.nodeRelSize;\n            var numSegments = state.nodeResolution;\n            if (!obj.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || obj.geometry.parameters.radius !== radius || obj.geometry.parameters.widthSegments !== numSegments) {\n              if (!sphereGeometries.hasOwnProperty(val)) {\n                sphereGeometries[val] = new three$1.SphereGeometry(radius, numSegments, numSegments);\n              }\n              obj.geometry.dispose();\n              obj.geometry = sphereGeometries[val];\n            }\n            var color = colorAccessor(node);\n            var materialColor = new three$1.Color(colorStr2Hex(color || '#ffffaa'));\n            var opacity = state.nodeOpacity * colorAlpha(color);\n            if (obj.material.type !== 'MeshLambertMaterial' || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {\n              if (!sphereMaterials.hasOwnProperty(color)) {\n                sphereMaterials[color] = new three$1.MeshLambertMaterial({\n                  color: materialColor,\n                  transparent: true,\n                  opacity: opacity\n                });\n              }\n              obj.material.dispose();\n              obj.material = sphereMaterials[color];\n            }\n          }\n        }\n      });\n    }\n\n    // Digest links WebGL objects\n    if (state._flushObjects || hasAnyPropChanged(['graphData', 'linkThreeObject', 'linkThreeObjectExtend', 'linkMaterial', 'linkColor', 'linkWidth', 'linkVisibility', 'linkResolution', 'linkOpacity', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution'])) {\n      var _customObjectAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkThreeObject);\n      var _customObjectExtendAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkThreeObjectExtend);\n      var customMaterialAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkMaterial);\n      var _visibilityAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n      var _colorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n      var widthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n      var cylinderGeometries = {}; // indexed by link width\n      var lambertLineMaterials = {}; // for cylinder objects, indexed by link color\n      var basicLineMaterials = {}; // for line objects, indexed by link color\n\n      var visibleLinks = state.graphData.links.filter(_visibilityAccessor);\n\n      // lines digest cycle\n      threeDigest(visibleLinks, state.graphScene, {\n        objBindAttr: '__lineObj',\n        purge: state._flushObjects || hasAnyPropChanged([\n        // recreate objects if any of these props have changed\n        'linkThreeObject', 'linkThreeObjectExtend', 'linkWidth']),\n        objFilter: function objFilter(obj) {\n          return obj.__graphObjType === 'link';\n        },\n        exitObj: function exitObj(obj) {\n          // remove trailing single photons\n          var singlePhotonsObj = obj.__data && obj.__data.__singleHopPhotonsObj;\n          if (singlePhotonsObj) {\n            singlePhotonsObj.parent.remove(singlePhotonsObj);\n            emptyObject(singlePhotonsObj);\n            delete obj.__data.__singleHopPhotonsObj;\n          }\n        },\n        createObj: function createObj(link) {\n          var customObj = _customObjectAccessor(link);\n          var extendObj = _customObjectExtendAccessor(link);\n          if (customObj && state.linkThreeObject === customObj) {\n            // clone object if it's a shared object among all links\n            customObj = customObj.clone();\n          }\n          var defaultObj;\n          if (!customObj || extendObj) {\n            // construct default line obj\n            var useCylinder = !!widthAccessor(link);\n            if (useCylinder) {\n              defaultObj = new three$1.Mesh();\n            } else {\n              // Use plain line (constant width)\n              var lineGeometry = new three$1.BufferGeometry();\n              lineGeometry[setAttributeFn]('position', new three$1.BufferAttribute(new Float32Array(2 * 3), 3));\n              defaultObj = new three$1.Line(lineGeometry);\n            }\n          }\n          var obj;\n          if (!customObj) {\n            obj = defaultObj;\n            obj.__graphDefaultObj = true;\n          } else {\n            if (!extendObj) {\n              // use custom object\n              obj = customObj;\n            } else {\n              // extend default with custom in a group\n              obj = new three$1.Group();\n              obj.__graphDefaultObj = true;\n              obj.add(defaultObj);\n              obj.add(customObj);\n            }\n          }\n          obj.renderOrder = 10; // Prevent visual glitches of dark lines on top of nodes by rendering them last\n\n          obj.__graphObjType = 'link'; // Add object type\n\n          return obj;\n        },\n        updateObj: function updateObj(updObj, link) {\n          if (updObj.__graphDefaultObj) {\n            // bypass internal updates for custom link objects\n            // select default object if it's an extended group\n            var obj = updObj.children.length ? updObj.children[0] : updObj;\n            var linkWidth = Math.ceil(widthAccessor(link) * 10) / 10;\n            var useCylinder = !!linkWidth;\n            if (useCylinder) {\n              var r = linkWidth / 2;\n              var numSegments = state.linkResolution;\n              if (!obj.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || obj.geometry.parameters.radiusTop !== r || obj.geometry.parameters.radialSegments !== numSegments) {\n                if (!cylinderGeometries.hasOwnProperty(linkWidth)) {\n                  var geometry = new three$1.CylinderGeometry(r, r, 1, numSegments, 1, false);\n                  geometry[applyMatrix4Fn](new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));\n                  geometry[applyMatrix4Fn](new three$1.Matrix4().makeRotationX(Math.PI / 2));\n                  cylinderGeometries[linkWidth] = geometry;\n                }\n                obj.geometry.dispose();\n                obj.geometry = cylinderGeometries[linkWidth];\n              }\n            }\n            var customMaterial = customMaterialAccessor(link);\n            if (customMaterial) {\n              obj.material = customMaterial;\n            } else {\n              var color = _colorAccessor(link);\n              var materialColor = new three$1.Color(colorStr2Hex(color || '#f0f0f0'));\n              var opacity = state.linkOpacity * colorAlpha(color);\n              var materialType = useCylinder ? 'MeshLambertMaterial' : 'LineBasicMaterial';\n              if (obj.material.type !== materialType || !obj.material.color.equals(materialColor) || obj.material.opacity !== opacity) {\n                var lineMaterials = useCylinder ? lambertLineMaterials : basicLineMaterials;\n                if (!lineMaterials.hasOwnProperty(color)) {\n                  lineMaterials[color] = new three$1[materialType]({\n                    color: materialColor,\n                    transparent: opacity < 1,\n                    opacity: opacity,\n                    depthWrite: opacity >= 1 // Prevent transparency issues\n                  });\n                }\n                obj.material.dispose();\n                obj.material = lineMaterials[color];\n              }\n            }\n          }\n        }\n      });\n\n      // Arrows digest cycle\n      if (state.linkDirectionalArrowLength || changedProps.hasOwnProperty('linkDirectionalArrowLength')) {\n        var arrowLengthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var arrowColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor);\n        threeDigest(visibleLinks.filter(arrowLengthAccessor), state.graphScene, {\n          objBindAttr: '__arrowObj',\n          objFilter: function objFilter(obj) {\n            return obj.__linkThreeObjType === 'arrow';\n          },\n          createObj: function createObj() {\n            var obj = new three$1.Mesh(undefined, new three$1.MeshLambertMaterial({\n              transparent: true\n            }));\n            obj.__linkThreeObjType = 'arrow'; // Add object type\n\n            return obj;\n          },\n          updateObj: function updateObj(obj, link) {\n            var arrowLength = arrowLengthAccessor(link);\n            var numSegments = state.linkDirectionalArrowResolution;\n            if (!obj.geometry.type.match(/^Cone(Buffer)?Geometry$/) || obj.geometry.parameters.height !== arrowLength || obj.geometry.parameters.radialSegments !== numSegments) {\n              var coneGeometry = new three$1.ConeGeometry(arrowLength * 0.25, arrowLength, numSegments);\n              // Correct orientation\n              coneGeometry.translate(0, arrowLength / 2, 0);\n              coneGeometry.rotateX(Math.PI / 2);\n              obj.geometry.dispose();\n              obj.geometry = coneGeometry;\n            }\n            var arrowColor = arrowColorAccessor(link) || _colorAccessor(link) || '#f0f0f0';\n            obj.material.color = new three$1.Color(colorStr2Hex(arrowColor));\n            obj.material.opacity = state.linkOpacity * 3 * colorAlpha(arrowColor);\n          }\n        });\n      }\n\n      // Photon particles digest cycle\n      if (state.linkDirectionalParticles || changedProps.hasOwnProperty('linkDirectionalParticles')) {\n        var particlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var particleWidthAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var particleColorAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor);\n        var particleMaterials = {}; // indexed by link color\n        var particleGeometries = {}; // indexed by particle width\n\n        threeDigest(visibleLinks.filter(particlesAccessor), state.graphScene, {\n          objBindAttr: '__photonsObj',\n          objFilter: function objFilter(obj) {\n            return obj.__linkThreeObjType === 'photons';\n          },\n          createObj: function createObj() {\n            var obj = new three$1.Group();\n            obj.__linkThreeObjType = 'photons'; // Add object type\n\n            return obj;\n          },\n          updateObj: function updateObj(obj, link) {\n            var numPhotons = Math.round(Math.abs(particlesAccessor(link)));\n            var curPhoton = !!obj.children.length && obj.children[0];\n            var photonR = Math.ceil(particleWidthAccessor(link) * 10) / 10 / 2;\n            var numSegments = state.linkDirectionalParticleResolution;\n            var particleGeometry;\n            if (curPhoton && curPhoton.geometry.parameters.radius === photonR && curPhoton.geometry.parameters.widthSegments === numSegments) {\n              particleGeometry = curPhoton.geometry;\n            } else {\n              if (!particleGeometries.hasOwnProperty(photonR)) {\n                particleGeometries[photonR] = new three$1.SphereGeometry(photonR, numSegments, numSegments);\n              }\n              particleGeometry = particleGeometries[photonR];\n              curPhoton && curPhoton.geometry.dispose();\n            }\n            var photonColor = particleColorAccessor(link) || _colorAccessor(link) || '#f0f0f0';\n            var materialColor = new three$1.Color(colorStr2Hex(photonColor));\n            var opacity = state.linkOpacity * 3;\n            var particleMaterial;\n            if (curPhoton && curPhoton.material.color.equals(materialColor) && curPhoton.material.opacity === opacity) {\n              particleMaterial = curPhoton.material;\n            } else {\n              if (!particleMaterials.hasOwnProperty(photonColor)) {\n                particleMaterials[photonColor] = new three$1.MeshLambertMaterial({\n                  color: materialColor,\n                  transparent: true,\n                  opacity: opacity\n                });\n              }\n              particleMaterial = particleMaterials[photonColor];\n              curPhoton && curPhoton.material.dispose();\n            }\n\n            // digest cycle for each photon\n            threeDigest(_toConsumableArray(new Array(numPhotons)).map(function (_, idx) {\n              return {\n                idx: idx\n              };\n            }), obj, {\n              idAccessor: function idAccessor(d) {\n                return d.idx;\n              },\n              createObj: function createObj() {\n                return new three$1.Mesh(particleGeometry, particleMaterial);\n              },\n              updateObj: function updateObj(obj) {\n                obj.geometry = particleGeometry;\n                obj.material = particleMaterial;\n              }\n            });\n          }\n        });\n      }\n    }\n    state._flushObjects = false; // reset objects refresh flag\n\n    // simulation engine\n    if (hasAnyPropChanged(['graphData', 'nodeId', 'linkSource', 'linkTarget', 'numDimensions', 'forceEngine', 'dagMode', 'dagNodeFilter', 'dagLevelDistance'])) {\n      state.engineRunning = false; // Pause simulation\n\n      // parse links\n      state.graphData.links.forEach(function (link) {\n        link.source = link[state.linkSource];\n        link.target = link[state.linkTarget];\n      });\n\n      // Feed data to force-directed layout\n      var isD3Sim = state.forceEngine !== 'ngraph';\n      var layout;\n      if (isD3Sim) {\n        // D3-force\n        (layout = state.d3ForceLayout).stop().alpha(1) // re-heat the simulation\n        .numDimensions(state.numDimensions).nodes(state.graphData.nodes);\n\n        // add links (if link force is still active)\n        var linkForce = state.d3ForceLayout.force('link');\n        if (linkForce) {\n          linkForce.id(function (d) {\n            return d[state.nodeId];\n          }).links(state.graphData.links);\n        }\n\n        // setup dag force constraints\n        var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n          return node[state.nodeId];\n        }, {\n          nodeFilter: state.dagNodeFilter,\n          onLoopError: state.onDagError || undefined\n        });\n        var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n        var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n        // Fix nodes to x,y,z for dag mode\n        if (state.dagMode) {\n          var getFFn = function getFFn(fix, invert) {\n            return function (node) {\n              return !fix ? undefined : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n            };\n          };\n          var fxFn = getFFn(['lr', 'rl'].indexOf(state.dagMode) !== -1, state.dagMode === 'rl');\n          var fyFn = getFFn(['td', 'bu'].indexOf(state.dagMode) !== -1, state.dagMode === 'td');\n          var fzFn = getFFn(['zin', 'zout'].indexOf(state.dagMode) !== -1, state.dagMode === 'zout');\n          state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n            node.fx = fxFn(node);\n            node.fy = fyFn(node);\n            node.fz = fzFn(node);\n          });\n        }\n\n        // Use radial force for radial dags\n        state.d3ForceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(function (node) {\n          var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n          return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n        }).strength(function (node) {\n          return state.dagNodeFilter(node) ? 1 : 0;\n        }) : null);\n      } else {\n        // ngraph\n        var _graph = ngraph.graph();\n        state.graphData.nodes.forEach(function (node) {\n          _graph.addNode(node[state.nodeId]);\n        });\n        state.graphData.links.forEach(function (link) {\n          _graph.addLink(link.source, link.target);\n        });\n        layout = ngraph.forcelayout(_graph, _objectSpread2({\n          dimensions: state.numDimensions\n        }, state.ngraphPhysics));\n        layout.graph = _graph; // Attach graph reference to layout\n      }\n      for (var i = 0; i < state.warmupTicks && !(isD3Sim && state.d3AlphaMin > 0 && state.d3ForceLayout.alpha() < state.d3AlphaMin); i++) {\n        layout[isD3Sim ? \"tick\" : \"step\"]();\n      } // Initial ticks before starting to render\n\n      state.layout = layout;\n      this.resetCountdown();\n    }\n    state.engineRunning = true; // resume simulation\n\n    state.onFinishUpdate();\n  }\n});\n\nfunction fromKapsule (kapsule) {\n  var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object;\n  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var FromKapsule = /*#__PURE__*/function (_baseClass) {\n    _inherits(FromKapsule, _baseClass);\n    function FromKapsule() {\n      var _this;\n      _classCallCheck(this, FromKapsule);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, FromKapsule, [].concat(args));\n      _this.__kapsuleInstance = kapsule().apply(void 0, [].concat(_toConsumableArray(initKapsuleWithSelf ? [_assertThisInitialized(_this)] : []), args));\n      return _this;\n    }\n    return _createClass(FromKapsule);\n  }(baseClass); // attach kapsule props/methods to class prototype\n  Object.keys(kapsule()).forEach(function (m) {\n    return FromKapsule.prototype[m] = function () {\n      var _this$__kapsuleInstan;\n      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m].apply(_this$__kapsuleInstan, arguments);\n      return returnVal === this.__kapsuleInstance ? this // chain based on this class, not the kapsule obj\n      : returnVal;\n    };\n  });\n  return FromKapsule;\n}\n\nvar three = window.THREE ? window.THREE : {\n  Group: three__WEBPACK_IMPORTED_MODULE_7__.Group\n}; // Prefer consumption from global THREE, if exists\nvar threeForcegraph = fromKapsule(ForceGraph, three.Group, true);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdGhyZWUtZm9yY2VncmFwaEAxLjQxLjE0X3RocmVlQDAuMTY3LjEvbm9kZV9tb2R1bGVzL3RocmVlLWZvcmNlZ3JhcGgvZGlzdC90aHJlZS1mb3JjZWdyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwUDtBQUN4SjtBQUNqRTtBQUNZO0FBQ2Y7QUFDTztBQUNEO0FBQ0Q7QUFDSztBQUNVO0FBQ2Y7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksa0VBQWtFO0FBQ3RGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFNBQVMsc0RBQVM7QUFDbEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLCtCQUErQixzREFBUztBQUN4QztBQUNBO0FBQ0Esc0JBQXNCLHNEQUFTO0FBQy9CO0FBQ0EscUJBQXFCLG9EQUFZLENBQUMsMERBQVk7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHdDQUFLO0FBQ2QsUUFBUSx1Q0FBSTtBQUNaLHVCQUF1QixzREFBbUI7QUFDMUMsU0FBUyx3Q0FBSztBQUNkLGtCQUFrQixpREFBYztBQUNoQyxtQkFBbUIsa0RBQWU7QUFDbEMsV0FBVywwQ0FBTztBQUNsQixXQUFXLDBDQUFPO0FBQ2xCLGtCQUFrQixpREFBYztBQUNoQyxvQkFBb0IsbURBQWdCO0FBQ3BDLGdCQUFnQiwrQ0FBWTtBQUM1QixnQkFBZ0IsK0NBQVk7QUFDNUIsUUFBUSx1Q0FBSTtBQUNaLHFCQUFxQixvREFBaUI7QUFDdEMseUJBQXlCLHdEQUFxQjtBQUM5QyxxQkFBcUIsb0RBQWlCO0FBQ3RDLFFBQVEsdUNBQUk7QUFDWjtBQUNBO0FBQ0EsU0FBUyx5Q0FBSztBQUNkLGVBQWUsK0NBQVc7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix1Q0FBdUM7QUFDdkMsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0EsS0FBSztBQUNMLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHlGQUF5RixRQUFRO0FBQ2pHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHlGQUF5RixTQUFTLFFBQVEsVUFBVSxVQUFVO0FBQzlIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxVQUFVO0FBQ1YscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSw0Q0FBNEMsdURBQVU7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0NBQWdDLHVEQUFVO0FBQzFDLG9DQUFvQyx1REFBVTtBQUM5Qyx3Q0FBd0MsdURBQVU7QUFDbEQsNENBQTRDLHVEQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRzs7QUFFaEcsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVEQUFVO0FBQzVDLGtDQUFrQyx1REFBVTtBQUM1Qyw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLGlEQUFpRDtBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1REFBVTtBQUMxQyxvQ0FBb0MsdURBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU0sb0RBQUc7QUFDMUM7QUFDQSxTQUFTLEdBQUcscURBQUc7QUFDZjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQix3REFBZSxpQkFBaUIsd0RBQVMsb0JBQW9CLHdEQUFhLG9CQUFvQix3REFBVztBQUM5SDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdURBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVEQUFVO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQVU7QUFDM0MsdUNBQXVDLHVEQUFVO0FBQ2pELHdCQUF3Qix1REFBVTtBQUNsQywwQkFBMEIsdURBQVU7QUFDcEMsK0JBQStCLHVEQUFVO0FBQ3pDLGlDQUFpQztBQUNqQyxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyx1REFBVTtBQUM1Qyx3Q0FBd0MsdURBQVU7QUFDbEQsbUNBQW1DLHVEQUFVO0FBQzdDLGdDQUFnQyx1REFBVTtBQUMxQywyQkFBMkIsdURBQVU7QUFDckMsMEJBQTBCLHVEQUFVO0FBQ3BDLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckMsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQyx1Q0FBdUM7O0FBRXZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxrQ0FBa0MsdURBQVU7QUFDNUMsaUNBQWlDLHVEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw4Q0FBOEM7O0FBRTlDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVO0FBQzFDLG9DQUFvQyx1REFBVTtBQUM5QyxvQ0FBb0MsdURBQVU7QUFDOUMsb0NBQW9DO0FBQ3BDLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSx5R0FBeUcsd0RBQVc7QUFDcEg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQjtBQUMvQjtBQUNBLHNCQUFzQiwrR0FBK0c7QUFDckk7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHdDQUFLO0FBQ2QsR0FBRztBQUNIOztBQUVzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYV9wb3N0X3NjYXJjaXR5Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVlLWZvcmNlZ3JhcGhAMS40MS4xNF90aHJlZUAwLjE2Ny4xL25vZGVfbW9kdWxlcy90aHJlZS1mb3JjZWdyYXBoL2Rpc3QvdGhyZWUtZm9yY2VncmFwaC5tanM/MzFmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcm91cCwgTWVzaCwgTWVzaExhbWJlcnRNYXRlcmlhbCwgQ29sb3IsIEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIE1hdHJpeDQsIFZlY3RvcjMsIFNwaGVyZUdlb21ldHJ5LCBDeWxpbmRlckdlb21ldHJ5LCBUdWJlR2VvbWV0cnksIENvbmVHZW9tZXRyeSwgTGluZSwgTGluZUJhc2ljTWF0ZXJpYWwsIFF1YWRyYXRpY0JlemllckN1cnZlMywgQ3ViaWNCZXppZXJDdXJ2ZTMsIEJveDMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBmb3JjZVNpbXVsYXRpb24sIGZvcmNlTGluaywgZm9yY2VNYW55Qm9keSwgZm9yY2VDZW50ZXIsIGZvcmNlUmFkaWFsIH0gZnJvbSAnZDMtZm9yY2UtM2QnO1xuaW1wb3J0IGdyYXBoIGZyb20gJ25ncmFwaC5ncmFwaCc7XG5pbXBvcnQgZm9yY2VsYXlvdXQgZnJvbSAnbmdyYXBoLmZvcmNlbGF5b3V0JztcbmltcG9ydCBLYXBzdWxlIGZyb20gJ2thcHN1bGUnO1xuaW1wb3J0IGFjY2Vzc29yRm4gZnJvbSAnYWNjZXNzb3ItZm4nO1xuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgZGF0YUpvaW50IGZyb20gJ2RhdGEtam9pbnQnO1xuaW1wb3J0IHsgc2NhbGVPcmRpbmFsIH0gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHsgc2NoZW1lUGFpcmVkIH0gZnJvbSAnZDMtc2NhbGUtY2hyb21hdGljJztcbmltcG9ydCB0aW55Q29sb3IgZnJvbSAndGlueWNvbG9yMic7XG5cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuZnVuY3Rpb24gX2NvbnN0cnVjdCh0LCBlLCByKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB2YXIgbyA9IFtudWxsXTtcbiAgby5wdXNoLmFwcGx5KG8sIGUpO1xuICB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpO1xuICByZXR1cm4gciAmJiBfc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG1hdGVyaWFsRGlzcG9zZSA9IGZ1bmN0aW9uIG1hdGVyaWFsRGlzcG9zZShtYXRlcmlhbCkge1xuICBpZiAobWF0ZXJpYWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIG1hdGVyaWFsLmZvckVhY2gobWF0ZXJpYWxEaXNwb3NlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICBtYXRlcmlhbC5tYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gIH1cbn07XG52YXIgZGVhbGxvY2F0ZSA9IGZ1bmN0aW9uIGRlYWxsb2NhdGUob2JqKSB7XG4gIGlmIChvYmouZ2VvbWV0cnkpIHtcbiAgICBvYmouZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG4gIGlmIChvYmoubWF0ZXJpYWwpIHtcbiAgICBtYXRlcmlhbERpc3Bvc2Uob2JqLm1hdGVyaWFsKTtcbiAgfVxuICBpZiAob2JqLnRleHR1cmUpIHtcbiAgICBvYmoudGV4dHVyZS5kaXNwb3NlKCk7XG4gIH1cbiAgaWYgKG9iai5jaGlsZHJlbikge1xuICAgIG9iai5jaGlsZHJlbi5mb3JFYWNoKGRlYWxsb2NhdGUpO1xuICB9XG59O1xudmFyIGVtcHR5T2JqZWN0ID0gZnVuY3Rpb24gZW1wdHlPYmplY3Qob2JqKSB7XG4gIHdoaWxlIChvYmouY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGNoaWxkT2JqID0gb2JqLmNoaWxkcmVuWzBdO1xuICAgIG9iai5yZW1vdmUoY2hpbGRPYmopO1xuICAgIGRlYWxsb2NhdGUoY2hpbGRPYmopO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wib2JqRmlsdGVyXCJdO1xuZnVuY3Rpb24gdGhyZWVEaWdlc3QoZGF0YSwgc2NlbmUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgIF9yZWYkb2JqRmlsdGVyID0gX3JlZi5vYmpGaWx0ZXIsXG4gICAgb2JqRmlsdGVyID0gX3JlZiRvYmpGaWx0ZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gOiBfcmVmJG9iakZpbHRlcixcbiAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHJldHVybiBkYXRhSm9pbnQoZGF0YSwgc2NlbmUuY2hpbGRyZW4uZmlsdGVyKG9iakZpbHRlciksIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gc2NlbmUuYWRkKG9iaik7XG4gIH0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICBzY2VuZS5yZW1vdmUob2JqKTtcbiAgICBlbXB0eU9iamVjdChvYmopO1xuICB9LCBfb2JqZWN0U3ByZWFkMih7XG4gICAgb2JqQmluZEF0dHI6ICdfX3RocmVlT2JqJ1xuICB9LCBvcHRpb25zKSk7XG59XG5cbnZhciBjb2xvclN0cjJIZXggPSBmdW5jdGlvbiBjb2xvclN0cjJIZXgoc3RyKSB7XG4gIHJldHVybiBpc05hTihzdHIpID8gcGFyc2VJbnQodGlueUNvbG9yKHN0cikudG9IZXgoKSwgMTYpIDogc3RyO1xufTtcbnZhciBjb2xvckFscGhhID0gZnVuY3Rpb24gY29sb3JBbHBoYShzdHIpIHtcbiAgcmV0dXJuIGlzTmFOKHN0cikgPyB0aW55Q29sb3Ioc3RyKS5nZXRBbHBoYSgpIDogMTtcbn07XG52YXIgYXV0b0NvbG9yU2NhbGUgPSBzY2FsZU9yZGluYWwoc2NoZW1lUGFpcmVkKTtcblxuLy8gQXV0b3NldCBhdHRyaWJ1dGUgY29sb3JGaWVsZCBieSBjb2xvckJ5QWNjZXNzb3IgcHJvcGVydHlcbi8vIElmIGFuIG9iamVjdCBoYXMgYWxyZWFkeSBhIGNvbG9yLCBkb24ndCBzZXQgaXRcbi8vIE9iamVjdHMgY2FuIGJlIG5vZGVzIG9yIGxpbmtzXG5mdW5jdGlvbiBhdXRvQ29sb3JPYmplY3RzKG9iamVjdHMsIGNvbG9yQnlBY2Nlc3NvciwgY29sb3JGaWVsZCkge1xuICBpZiAoIWNvbG9yQnlBY2Nlc3NvciB8fCB0eXBlb2YgY29sb3JGaWVsZCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAhb2JqW2NvbG9yRmllbGRdO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYmpbY29sb3JGaWVsZF0gPSBhdXRvQ29sb3JTY2FsZShjb2xvckJ5QWNjZXNzb3Iob2JqKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREYWdEZXB0aHMgKF9yZWYsIGlkQWNjZXNzb3IpIHtcbiAgdmFyIG5vZGVzID0gX3JlZi5ub2RlcyxcbiAgICBsaW5rcyA9IF9yZWYubGlua3M7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgX3JlZjIkbm9kZUZpbHRlciA9IF9yZWYyLm5vZGVGaWx0ZXIsXG4gICAgbm9kZUZpbHRlciA9IF9yZWYyJG5vZGVGaWx0ZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gOiBfcmVmMiRub2RlRmlsdGVyLFxuICAgIF9yZWYyJG9uTG9vcEVycm9yID0gX3JlZjIub25Mb29wRXJyb3IsXG4gICAgb25Mb29wRXJyb3IgPSBfcmVmMiRvbkxvb3BFcnJvciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGxvb3BJZHMpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBEQUcgc3RydWN0dXJlISBGb3VuZCBjeWNsZSBpbiBub2RlIHBhdGg6IFwiLmNvbmNhdChsb29wSWRzLmpvaW4oJyAtPiAnKSwgXCIuXCIpO1xuICAgIH0gOiBfcmVmMiRvbkxvb3BFcnJvcjtcbiAgLy8gbGlua2VkIGdyYXBoXG4gIHZhciBncmFwaCA9IHt9O1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGdyYXBoW2lkQWNjZXNzb3Iobm9kZSldID0ge1xuICAgICAgZGF0YTogbm9kZSxcbiAgICAgIG91dDogW10sXG4gICAgICBkZXB0aDogLTEsXG4gICAgICBza2lwOiAhbm9kZUZpbHRlcihub2RlKVxuICAgIH07XG4gIH0pO1xuICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBzb3VyY2UgPSBfcmVmMy5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmMy50YXJnZXQ7XG4gICAgdmFyIHNvdXJjZUlkID0gZ2V0Tm9kZUlkKHNvdXJjZSk7XG4gICAgdmFyIHRhcmdldElkID0gZ2V0Tm9kZUlkKHRhcmdldCk7XG4gICAgaWYgKCFncmFwaC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHRocm93IFwiTWlzc2luZyBzb3VyY2Ugbm9kZSB3aXRoIGlkOiBcIi5jb25jYXQoc291cmNlSWQpO1xuICAgIGlmICghZ3JhcGguaGFzT3duUHJvcGVydHkodGFyZ2V0SWQpKSB0aHJvdyBcIk1pc3NpbmcgdGFyZ2V0IG5vZGUgd2l0aCBpZDogXCIuY29uY2F0KHRhcmdldElkKTtcbiAgICB2YXIgc291cmNlTm9kZSA9IGdyYXBoW3NvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGdyYXBoW3RhcmdldElkXTtcbiAgICBzb3VyY2VOb2RlLm91dC5wdXNoKHRhcmdldE5vZGUpO1xuICAgIGZ1bmN0aW9uIGdldE5vZGVJZChub2RlKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZihub2RlKSA9PT0gJ29iamVjdCcgPyBpZEFjY2Vzc29yKG5vZGUpIDogbm9kZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZm91bmRMb29wcyA9IFtdO1xuICB0cmF2ZXJzZShPYmplY3QudmFsdWVzKGdyYXBoKSk7XG4gIHZhciBub2RlRGVwdGhzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt7fV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3QuZW50cmllcyhncmFwaCkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAyKSxcbiAgICAgIG5vZGUgPSBfcmVmNVsxXTtcbiAgICByZXR1cm4gIW5vZGUuc2tpcDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgIGlkID0gX3JlZjdbMF0sXG4gICAgICBub2RlID0gX3JlZjdbMV07XG4gICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaWQsIG5vZGUuZGVwdGgpO1xuICB9KSkpKTtcbiAgcmV0dXJuIG5vZGVEZXB0aHM7XG4gIGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGVzKSB7XG4gICAgdmFyIG5vZGVTdGFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdmFyIGN1cnJlbnREZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgIHZhciBsb29wID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlU3RhY2suc2xpY2Uobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkpKSwgW25vZGVdKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gaWRBY2Nlc3NvcihkLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmb3VuZExvb3BzLnNvbWUoZnVuY3Rpb24gKGZvdW5kTG9vcCkge1xuICAgICAgICAgIHJldHVybiBmb3VuZExvb3AubGVuZ3RoID09PSBsb29wLmxlbmd0aCAmJiBmb3VuZExvb3AuZXZlcnkoZnVuY3Rpb24gKGlkLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gbG9vcFtpZHhdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGZvdW5kTG9vcHMucHVzaChsb29wKTtcbiAgICAgICAgICBvbkxvb3BFcnJvcihsb29wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTsgLy8gY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RGVwdGggPiBub2RlLmRlcHRoKSB7XG4gICAgICAgIC8vIERvbid0IHVubmVjZXNzYXJpbHkgcmV2aXNpdCBjaHVua3Mgb2YgdGhlIGdyYXBoXG4gICAgICAgIG5vZGUuZGVwdGggPSBjdXJyZW50RGVwdGg7XG4gICAgICAgIHRyYXZlcnNlKG5vZGUub3V0LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVTdGFjayksIFtub2RlXSksIGN1cnJlbnREZXB0aCArIChub2RlLnNraXAgPyAwIDogMSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChfbG9vcCgpKSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHRocmVlJDEgPSB3aW5kb3cuVEhSRUUgPyB3aW5kb3cuVEhSRUUgLy8gUHJlZmVyIGNvbnN1bXB0aW9uIGZyb20gZ2xvYmFsIFRIUkVFLCBpZiBleGlzdHNcbjoge1xuICBHcm91cDogR3JvdXAsXG4gIE1lc2g6IE1lc2gsXG4gIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6IE1lc2hMYW1iZXJ0TWF0ZXJpYWwsXG4gIENvbG9yOiBDb2xvcixcbiAgQnVmZmVyR2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5LFxuICBCdWZmZXJBdHRyaWJ1dGU6IEJ1ZmZlckF0dHJpYnV0ZSxcbiAgTWF0cml4NDogTWF0cml4NCxcbiAgVmVjdG9yMzogVmVjdG9yMyxcbiAgU3BoZXJlR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxuICBDeWxpbmRlckdlb21ldHJ5OiBDeWxpbmRlckdlb21ldHJ5LFxuICBUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcbiAgQ29uZUdlb21ldHJ5OiBDb25lR2VvbWV0cnksXG4gIExpbmU6IExpbmUsXG4gIExpbmVCYXNpY01hdGVyaWFsOiBMaW5lQmFzaWNNYXRlcmlhbCxcbiAgUXVhZHJhdGljQmV6aWVyQ3VydmUzOiBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMsXG4gIEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcbiAgQm94MzogQm94M1xufTtcbnZhciBuZ3JhcGggPSB7XG4gIGdyYXBoOiBncmFwaCxcbiAgZm9yY2VsYXlvdXQ6IGZvcmNlbGF5b3V0XG59O1xuXG4vL1xuXG52YXIgREFHX0xFVkVMX05PREVfUkFUSU8gPSAyO1xuXG4vLyBzdXBwb3J0IG11bHRpcGxlIG1ldGhvZCBuYW1lcyBmb3IgYmFja3dhcmRzIHRocmVlanMgY29tcGF0aWJpbGl0eVxudmFyIHNldEF0dHJpYnV0ZUZuID0gbmV3IHRocmVlJDEuQnVmZmVyR2VvbWV0cnkoKS5zZXRBdHRyaWJ1dGUgPyAnc2V0QXR0cmlidXRlJyA6ICdhZGRBdHRyaWJ1dGUnO1xudmFyIGFwcGx5TWF0cml4NEZuID0gbmV3IHRocmVlJDEuQnVmZmVyR2VvbWV0cnkoKS5hcHBseU1hdHJpeDQgPyAnYXBwbHlNYXRyaXg0JyA6ICdhcHBseU1hdHJpeCc7XG52YXIgRm9yY2VHcmFwaCA9IEthcHN1bGUoe1xuICBwcm9wczoge1xuICAgIGpzb25Vcmw6IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShqc29uVXJsLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoanNvblVybCAmJiAhc3RhdGUuZmV0Y2hpbmdKc29uKSB7XG4gICAgICAgICAgLy8gTG9hZCBkYXRhIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgc3RhdGUuZmV0Y2hpbmdKc29uID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS5vbkxvYWRpbmcoKTtcbiAgICAgICAgICBmZXRjaChqc29uVXJsKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5qc29uKCk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgc3RhdGUuZmV0Y2hpbmdKc29uID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5vbkZpbmlzaExvYWRpbmcoanNvbik7XG4gICAgICAgICAgICBfdGhpcy5ncmFwaERhdGEoanNvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZ3JhcGhEYXRhOiB7XG4gICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShncmFwaERhdGEsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gUGF1c2Ugc2ltdWxhdGlvbiBpbW1lZGlhdGVseVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVtRGltZW5zaW9uczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDMsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobnVtRGltLCBzdGF0ZSkge1xuICAgICAgICB2YXIgY2hhcmdlRm9yY2UgPSBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmZvcmNlKCdjaGFyZ2UnKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgcmVwdWxzaW9uIG9uIDNEIG1vZGUgZm9yIGltcHJvdmVkIHNwYXRpYWwgc2VwYXJhdGlvblxuICAgICAgICBpZiAoY2hhcmdlRm9yY2UpIHtcbiAgICAgICAgICBjaGFyZ2VGb3JjZS5zdHJlbmd0aChudW1EaW0gPiAyID8gLTYwIDogLTMwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtRGltIDwgMykge1xuICAgICAgICAgIGVyYXNlRGltZW5zaW9uKHN0YXRlLmdyYXBoRGF0YS5ub2RlcywgJ3onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtRGltIDwgMikge1xuICAgICAgICAgIGVyYXNlRGltZW5zaW9uKHN0YXRlLmdyYXBoRGF0YS5ub2RlcywgJ3knKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlcmFzZURpbWVuc2lvbihub2RlcywgZGltKSB7XG4gICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZGVsZXRlIGRbZGltXTsgLy8gcG9zaXRpb25cbiAgICAgICAgICAgIGRlbGV0ZSBkW1widlwiLmNvbmNhdChkaW0pXTsgLy8gdmVsb2NpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGFnTW9kZToge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGRhZ01vZGUsIHN0YXRlKSB7XG4gICAgICAgIC8vIHRkLCBidSwgbHIsIHJsLCB6aW4sIHpvdXQsIHJhZGlhbGluLCByYWRpYWxvdXRcbiAgICAgICAgIWRhZ01vZGUgJiYgc3RhdGUuZm9yY2VFbmdpbmUgPT09ICdkMycgJiYgKHN0YXRlLmdyYXBoRGF0YS5ub2RlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuLmZ4ID0gbi5meSA9IG4uZnogPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pOyAvLyB1bmZpeCBub2RlcyB3aGVuIGRpc2FibGluZyBkYWcgbW9kZVxuICAgICAgfVxuICAgIH0sXG4gICAgZGFnTGV2ZWxEaXN0YW5jZToge30sXG4gICAgZGFnTm9kZUZpbHRlcjoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkRhZ0Vycm9yOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZVJlbFNpemU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0XG4gICAgfSxcbiAgICAvLyB2b2x1bWUgcGVyIHZhbCB1bml0XG4gICAgbm9kZUlkOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2lkJ1xuICAgIH0sXG4gICAgbm9kZVZhbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICd2YWwnXG4gICAgfSxcbiAgICBub2RlUmVzb2x1dGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDhcbiAgICB9LFxuICAgIC8vIGhvdyBtYW55IHNsaWNlIHNlZ21lbnRzIGluIHRoZSBzcGhlcmUncyBjaXJjdW1mZXJlbmNlXG4gICAgbm9kZUNvbG9yOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2NvbG9yJ1xuICAgIH0sXG4gICAgbm9kZUF1dG9Db2xvckJ5OiB7fSxcbiAgICBub2RlT3BhY2l0eToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNzVcbiAgICB9LFxuICAgIG5vZGVWaXNpYmlsaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gICAgbm9kZVRocmVlT2JqZWN0OiB7fSxcbiAgICBub2RlVGhyZWVPYmplY3RFeHRlbmQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZVBvc2l0aW9uVXBkYXRlOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gY3VzdG9tIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIHVwZGF0aW5nIHRoZSBub2RlJ3MgcG9zaXRpb24uIFNpZ25hdHVyZTogKHRocmVlT2JqLCB7IHgsIHksIHp9LCBub2RlKS4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsIHRoZSByZWd1bGFyIG5vZGUgcG9zaXRpb24gdXBkYXRlIHdpbGwgbm90IHJ1bi5cbiAgICBsaW5rU291cmNlOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3NvdXJjZSdcbiAgICB9LFxuICAgIGxpbmtUYXJnZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAndGFyZ2V0J1xuICAgIH0sXG4gICAgbGlua1Zpc2liaWxpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlXG4gICAgfSxcbiAgICBsaW5rQ29sb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnY29sb3InXG4gICAgfSxcbiAgICBsaW5rQXV0b0NvbG9yQnk6IHt9LFxuICAgIGxpbmtPcGFjaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4yXG4gICAgfSxcbiAgICBsaW5rV2lkdGg6IHt9LFxuICAgIC8vIFJvdW5kZWQgdG8gbmVhcmVzdCBkZWNpbWFsLiBGb3IgZmFsc3kgdmFsdWVzIHVzZSBkaW1lbnNpb25sZXNzIGxpbmUgd2l0aCAxcHggcmVnYXJkbGVzcyBvZiBkaXN0YW5jZS5cbiAgICBsaW5rUmVzb2x1dGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDZcbiAgICB9LFxuICAgIC8vIGhvdyBtYW55IHJhZGlhbCBzZWdtZW50cyBpbiBlYWNoIGxpbmUgdHViZSdzIGdlb21ldHJ5XG4gICAgbGlua0N1cnZhdHVyZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gbGluZSBjdXJ2YXR1cmUgcmFkaXVzICgwOiBzdHJhaWdodCwgMTogc2VtaS1jaXJjbGUpXG4gICAgbGlua0N1cnZlUm90YXRpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIGxpbmUgY3VydmUgcm90YXRpb24gYWxvbmcgdGhlIGxpbmUgYXhpcyAoMDogaW50ZXJlY3Rpb24gd2l0aCBYWSBwbGFuZSwgUEk6IHVwc2lkZSBkb3duKVxuICAgIGxpbmtNYXRlcmlhbDoge30sXG4gICAgbGlua1RocmVlT2JqZWN0OiB7fSxcbiAgICBsaW5rVGhyZWVPYmplY3RFeHRlbmQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua1Bvc2l0aW9uVXBkYXRlOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gY3VzdG9tIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIHVwZGF0aW5nIHRoZSBsaW5rJ3MgcG9zaXRpb24uIFNpZ25hdHVyZTogKHRocmVlT2JqLCB7IHN0YXJ0OiB7IHgsIHksIHp9LCAgZW5kOiB7IHgsIHksIHogfX0sIGxpbmspLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhlIHJlZ3VsYXIgbGluayBwb3NpdGlvbiB1cGRhdGUgd2lsbCBub3QgcnVuLlxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMFxuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcjoge30sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gdmFsdWUgYmV0d2VlbiAwPD4xIGluZGljYXRpbmcgdGhlIHJlbGF0aXZlIHBvcyBhbG9uZyB0aGUgKGV4cG9zZWQpIGxpbmVcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd1Jlc29sdXRpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA4XG4gICAgfSxcbiAgICAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgYXJyb3cncyBjb25pYyBjaXJjdW1mZXJlbmNlXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVzOiB7XG4gICAgICBcImRlZmF1bHRcIjogMFxuICAgIH0sXG4gICAgLy8gYW5pbWF0ZSBwaG90b25zIHRyYXZlbGxpbmcgaW4gdGhlIGxpbmsgZGlyZWN0aW9uXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuMDEsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gaW4gbGluayBsZW5ndGggcmF0aW8gcGVyIGZyYW1lXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNVxuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcjoge30sXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVSZXNvbHV0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogNFxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgc2xpY2Ugc2VnbWVudHMgaW4gdGhlIHBhcnRpY2xlIHNwaGVyZSdzIGNpcmN1bWZlcmVuY2VcbiAgICBmb3JjZUVuZ2luZToge1xuICAgICAgXCJkZWZhdWx0XCI6ICdkMydcbiAgICB9LFxuICAgIC8vIGQzIG9yIG5ncmFwaFxuICAgIGQzQWxwaGFNaW46IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwXG4gICAgfSxcbiAgICBkM0FscGhhRGVjYXk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAyMjgsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShhbHBoYURlY2F5LCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmFscGhhRGVjYXkoYWxwaGFEZWNheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkM0FscGhhVGFyZ2V0OiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGFscGhhVGFyZ2V0LCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmFscGhhVGFyZ2V0KGFscGhhVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQzVmVsb2NpdHlEZWNheToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZlbG9jaXR5RGVjYXksIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmQzRm9yY2VMYXlvdXQudmVsb2NpdHlEZWNheSh2ZWxvY2l0eURlY2F5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5ncmFwaFBoeXNpY3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIC8vIGRlZmF1bHRzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FudmFrYS9uZ3JhcGgucGh5c2ljcy5zaW11bGF0b3IvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgICAgICAgdGltZVN0ZXA6IDIwLFxuICAgICAgICBncmF2aXR5OiAtMS4yLFxuICAgICAgICB0aGV0YTogMC44LFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDMwLFxuICAgICAgICBzcHJpbmdDb2VmZmljaWVudDogMC4wMDA4LFxuICAgICAgICBkcmFnQ29lZmZpY2llbnQ6IDAuMDJcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm11cFRpY2tzOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBob3cgbWFueSB0aW1lcyB0byB0aWNrIHRoZSBmb3JjZSBlbmdpbmUgYXQgaW5pdCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVuZGVyXG4gICAgY29vbGRvd25UaWNrczoge1xuICAgICAgXCJkZWZhdWx0XCI6IEluZmluaXR5LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGNvb2xkb3duVGltZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDE1MDAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIG1zXG4gICAgb25Mb2FkaW5nOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkZpbmlzaExvYWRpbmc6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uVXBkYXRlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkZpbmlzaFVwZGF0ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25FbmdpbmVUaWNrOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkVuZ2luZVN0b3A6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5fZmx1c2hPYmplY3RzID0gdHJ1ZTtcbiAgICAgIHN0YXRlLl9yZXJlbmRlcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBFeHBvc2UgZDMgZm9yY2VzIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cbiAgICBkM0ZvcmNlOiBmdW5jdGlvbiBkM0ZvcmNlKHN0YXRlLCBmb3JjZU5hbWUsIGZvcmNlRm4pIHtcbiAgICAgIGlmIChmb3JjZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmQzRm9yY2VMYXlvdXQuZm9yY2UoZm9yY2VOYW1lKTsgLy8gRm9yY2UgZ2V0dGVyXG4gICAgICB9XG4gICAgICBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmZvcmNlKGZvcmNlTmFtZSwgZm9yY2VGbik7IC8vIEZvcmNlIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkM1JlaGVhdFNpbXVsYXRpb246IGZ1bmN0aW9uIGQzUmVoZWF0U2ltdWxhdGlvbihzdGF0ZSkge1xuICAgICAgc3RhdGUuZDNGb3JjZUxheW91dC5hbHBoYSgxKTtcbiAgICAgIHRoaXMucmVzZXRDb3VudGRvd24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gcmVzZXQgY29vbGRvd24gc3RhdGVcbiAgICByZXNldENvdW50ZG93bjogZnVuY3Rpb24gcmVzZXRDb3VudGRvd24oc3RhdGUpIHtcbiAgICAgIHN0YXRlLmNudFRpY2tzID0gMDtcbiAgICAgIHN0YXRlLnN0YXJ0VGlja1RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRpY2tGcmFtZTogZnVuY3Rpb24gdGlja0ZyYW1lKHN0YXRlKSB7XG4gICAgICB2YXIgaXNEM1NpbSA9IHN0YXRlLmZvcmNlRW5naW5lICE9PSAnbmdyYXBoJztcbiAgICAgIGlmIChzdGF0ZS5lbmdpbmVSdW5uaW5nKSB7XG4gICAgICAgIGxheW91dFRpY2soKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUFycm93cygpO1xuICAgICAgdXBkYXRlUGhvdG9ucygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGxheW91dFRpY2soKSB7XG4gICAgICAgIGlmICgrK3N0YXRlLmNudFRpY2tzID4gc3RhdGUuY29vbGRvd25UaWNrcyB8fCBuZXcgRGF0ZSgpIC0gc3RhdGUuc3RhcnRUaWNrVGltZSA+IHN0YXRlLmNvb2xkb3duVGltZSB8fCBpc0QzU2ltICYmIHN0YXRlLmQzQWxwaGFNaW4gPiAwICYmIHN0YXRlLmQzRm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pIHtcbiAgICAgICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFN0b3AgdGlja2luZyBncmFwaFxuICAgICAgICAgIHN0YXRlLm9uRW5naW5lU3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxheW91dFtpc0QzU2ltID8gJ3RpY2snIDogJ3N0ZXAnXSgpOyAvLyBUaWNrIGl0XG4gICAgICAgICAgc3RhdGUub25FbmdpbmVUaWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVUaHJlZU9iamVjdEV4dGVuZEFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVGhyZWVPYmplY3RFeHRlbmQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyBwb3NpdGlvblxuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBvYmogPSBub2RlLl9fdGhyZWVPYmo7XG4gICAgICAgICAgaWYgKCFvYmopIHJldHVybjtcbiAgICAgICAgICB2YXIgcG9zID0gaXNEM1NpbSA/IG5vZGUgOiBzdGF0ZS5sYXlvdXQuZ2V0Tm9kZVBvc2l0aW9uKG5vZGVbc3RhdGUubm9kZUlkXSk7XG4gICAgICAgICAgdmFyIGV4dGVuZGVkT2JqID0gbm9kZVRocmVlT2JqZWN0RXh0ZW5kQWNjZXNzb3Iobm9kZSk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5ub2RlUG9zaXRpb25VcGRhdGUgfHwgIXN0YXRlLm5vZGVQb3NpdGlvblVwZGF0ZShleHRlbmRlZE9iaiA/IG9iai5jaGlsZHJlblswXSA6IG9iaiwge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueSxcbiAgICAgICAgICAgIHo6IHBvcy56XG4gICAgICAgICAgfSwgbm9kZSkgLy8gcGFzcyBjaGlsZCBjdXN0b20gb2JqZWN0IGlmIGV4dGVuZGluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgIHx8IGV4dGVuZGVkT2JqKSB7XG4gICAgICAgICAgICBvYmoucG9zaXRpb24ueCA9IHBvcy54O1xuICAgICAgICAgICAgb2JqLnBvc2l0aW9uLnkgPSBwb3MueSB8fCAwO1xuICAgICAgICAgICAgb2JqLnBvc2l0aW9uLnogPSBwb3MueiB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGxpbmtzIHBvc2l0aW9uXG4gICAgICAgIHZhciBsaW5rV2lkdGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1dpZHRoKTtcbiAgICAgICAgdmFyIGxpbmtDdXJ2YXR1cmVBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0N1cnZhdHVyZSk7XG4gICAgICAgIHZhciBsaW5rQ3VydmVSb3RhdGlvbkFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rQ3VydmVSb3RhdGlvbik7XG4gICAgICAgIHZhciBsaW5rVGhyZWVPYmplY3RFeHRlbmRBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1RocmVlT2JqZWN0RXh0ZW5kKTtcbiAgICAgICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICB2YXIgbGluZU9iaiA9IGxpbmsuX19saW5lT2JqO1xuICAgICAgICAgIGlmICghbGluZU9iaikgcmV0dXJuO1xuICAgICAgICAgIHZhciBwb3MgPSBpc0QzU2ltID8gbGluayA6IHN0YXRlLmxheW91dC5nZXRMaW5rUG9zaXRpb24oc3RhdGUubGF5b3V0LmdyYXBoLmdldExpbmsobGluay5zb3VyY2UsIGxpbmsudGFyZ2V0KS5pZCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcG9zW2lzRDNTaW0gPyAnc291cmNlJyA6ICdmcm9tJ107XG4gICAgICAgICAgdmFyIGVuZCA9IHBvc1tpc0QzU2ltID8gJ3RhcmdldCcgOiAndG8nXTtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICBjYWxjTGlua0N1cnZlKGxpbmspOyAvLyBjYWxjdWxhdGUgbGluayBjdXJ2ZSBmb3IgYWxsIGxpbmtzLCBpbmNsdWRpbmcgY3VzdG9tIHJlcGxhY2VkLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiBkaXJlY3Rpb25hbCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICB2YXIgZXh0ZW5kZWRPYmogPSBsaW5rVGhyZWVPYmplY3RFeHRlbmRBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUubGlua1Bvc2l0aW9uVXBkYXRlICYmIHN0YXRlLmxpbmtQb3NpdGlvblVwZGF0ZShleHRlbmRlZE9iaiA/IGxpbmVPYmouY2hpbGRyZW5bMV0gOiBsaW5lT2JqLFxuICAgICAgICAgIC8vIHBhc3MgY2hpbGQgY3VzdG9tIG9iamVjdCBpZiBleHRlbmRpbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICB4OiBzdGFydC54LFxuICAgICAgICAgICAgICB5OiBzdGFydC55LFxuICAgICAgICAgICAgICB6OiBzdGFydC56XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgIHg6IGVuZC54LFxuICAgICAgICAgICAgICB5OiBlbmQueSxcbiAgICAgICAgICAgICAgejogZW5kLnpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBsaW5rKSAmJiAhZXh0ZW5kZWRPYmopIHtcbiAgICAgICAgICAgIC8vIGV4aXQgaWYgc3VjY2Vzc2Z1bGx5IGN1c3RvbSB1cGRhdGVkIHBvc2l0aW9uIG9mIG5vbi1leHRlbmRlZCBvYmpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1cnZlUmVzb2x1dGlvbiA9IDMwOyAvLyAjIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICB2YXIgY3VydmUgPSBsaW5rLl9fY3VydmU7XG5cbiAgICAgICAgICAvLyBzZWxlY3QgZGVmYXVsdCBsaW5lIG9iaiBpZiBpdCdzIGFuIGV4dGVuZGVkIGdyb3VwXG4gICAgICAgICAgdmFyIGxpbmUgPSBsaW5lT2JqLmNoaWxkcmVuLmxlbmd0aCA/IGxpbmVPYmouY2hpbGRyZW5bMF0gOiBsaW5lT2JqO1xuICAgICAgICAgIGlmIChsaW5lLnR5cGUgPT09ICdMaW5lJykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxpbmUgZ2VvbWV0cnlcbiAgICAgICAgICAgIGlmICghY3VydmUpIHtcbiAgICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZVxuICAgICAgICAgICAgICB2YXIgbGluZVBvcyA9IGxpbmUuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgICBpZiAoIWxpbmVQb3MgfHwgIWxpbmVQb3MuYXJyYXkgfHwgbGluZVBvcy5hcnJheS5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgICAgICAgICBsaW5lLmdlb21ldHJ5W3NldEF0dHJpYnV0ZUZuXSgncG9zaXRpb24nLCBsaW5lUG9zID0gbmV3IHRocmVlJDEuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoMiAqIDMpLCAzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGluZVBvcy5hcnJheVswXSA9IHN0YXJ0Lng7XG4gICAgICAgICAgICAgIGxpbmVQb3MuYXJyYXlbMV0gPSBzdGFydC55IHx8IDA7XG4gICAgICAgICAgICAgIGxpbmVQb3MuYXJyYXlbMl0gPSBzdGFydC56IHx8IDA7XG4gICAgICAgICAgICAgIGxpbmVQb3MuYXJyYXlbM10gPSBlbmQueDtcbiAgICAgICAgICAgICAgbGluZVBvcy5hcnJheVs0XSA9IGVuZC55IHx8IDA7XG4gICAgICAgICAgICAgIGxpbmVQb3MuYXJyYXlbNV0gPSBlbmQueiB8fCAwO1xuICAgICAgICAgICAgICBsaW5lUG9zLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGJlemllciBjdXJ2ZSBsaW5lXG4gICAgICAgICAgICAgIGxpbmUuZ2VvbWV0cnkuc2V0RnJvbVBvaW50cyhjdXJ2ZS5nZXRQb2ludHMoY3VydmVSZXNvbHV0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGluZS50eXBlID09PSAnTWVzaCcpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjeWxpbmRlciBnZW9tZXRyeVxuXG4gICAgICAgICAgICBpZiAoIWN1cnZlKSB7XG4gICAgICAgICAgICAgIC8vIHN0cmFpZ2h0IHR1YmVcbiAgICAgICAgICAgICAgaWYgKCFsaW5lLmdlb21ldHJ5LnR5cGUubWF0Y2goL15DeWxpbmRlcihCdWZmZXIpP0dlb21ldHJ5JC8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtXaWR0aCA9IE1hdGguY2VpbChsaW5rV2lkdGhBY2Nlc3NvcihsaW5rKSAqIDEwKSAvIDEwO1xuICAgICAgICAgICAgICAgIHZhciByID0gbGlua1dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgdGhyZWUkMS5DeWxpbmRlckdlb21ldHJ5KHIsIHIsIDEsIHN0YXRlLmxpbmtSZXNvbHV0aW9uLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlbYXBwbHlNYXRyaXg0Rm5dKG5ldyB0aHJlZSQxLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oMCwgMSAvIDIsIDApKTtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeVthcHBseU1hdHJpeDRGbl0obmV3IHRocmVlJDEuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoTWF0aC5QSSAvIDIpKTtcbiAgICAgICAgICAgICAgICBsaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBsaW5lLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHZTdGFydCA9IG5ldyB0aHJlZSQxLlZlY3RvcjMoc3RhcnQueCwgc3RhcnQueSB8fCAwLCBzdGFydC56IHx8IDApO1xuICAgICAgICAgICAgICB2YXIgdkVuZCA9IG5ldyB0aHJlZSQxLlZlY3RvcjMoZW5kLngsIGVuZC55IHx8IDAsIGVuZC56IHx8IDApO1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB2U3RhcnQuZGlzdGFuY2VUbyh2RW5kKTtcbiAgICAgICAgICAgICAgbGluZS5wb3NpdGlvbi54ID0gdlN0YXJ0Lng7XG4gICAgICAgICAgICAgIGxpbmUucG9zaXRpb24ueSA9IHZTdGFydC55O1xuICAgICAgICAgICAgICBsaW5lLnBvc2l0aW9uLnogPSB2U3RhcnQuejtcbiAgICAgICAgICAgICAgbGluZS5zY2FsZS56ID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgIGxpbmUucGFyZW50LmxvY2FsVG9Xb3JsZCh2RW5kKTsgLy8gbG9va0F0IHJlcXVpcmVzIHdvcmxkIGNvb3Jkc1xuICAgICAgICAgICAgICBsaW5lLmxvb2tBdCh2RW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGN1cnZlZCB0dWJlXG4gICAgICAgICAgICAgIGlmICghbGluZS5nZW9tZXRyeS50eXBlLm1hdGNoKC9eVHViZShCdWZmZXIpP0dlb21ldHJ5JC8pKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgb2JqZWN0IHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAgICAgbGluZS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgbGluZS5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgbGluZS5zY2FsZS5zZXQoMSwgMSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9saW5rV2lkdGggPSBNYXRoLmNlaWwobGlua1dpZHRoQWNjZXNzb3IobGluaykgKiAxMCkgLyAxMDtcbiAgICAgICAgICAgICAgdmFyIF9yID0gX2xpbmtXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIHZhciBfZ2VvbWV0cnkgPSBuZXcgdGhyZWUkMS5UdWJlR2VvbWV0cnkoY3VydmUsIGN1cnZlUmVzb2x1dGlvbiwgX3IsIHN0YXRlLmxpbmtSZXNvbHV0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGxpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICBsaW5lLmdlb21ldHJ5ID0gX2dlb21ldHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBmdW5jdGlvbiBjYWxjTGlua0N1cnZlKGxpbmspIHtcbiAgICAgICAgICB2YXIgcG9zID0gaXNEM1NpbSA/IGxpbmsgOiBzdGF0ZS5sYXlvdXQuZ2V0TGlua1Bvc2l0aW9uKHN0YXRlLmxheW91dC5ncmFwaC5nZXRMaW5rKGxpbmsuc291cmNlLCBsaW5rLnRhcmdldCkuaWQpO1xuICAgICAgICAgIHZhciBzdGFydCA9IHBvc1tpc0QzU2ltID8gJ3NvdXJjZScgOiAnZnJvbSddO1xuICAgICAgICAgIHZhciBlbmQgPSBwb3NbaXNEM1NpbSA/ICd0YXJnZXQnIDogJ3RvJ107XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIGN1cnZhdHVyZSA9IGxpbmtDdXJ2YXR1cmVBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICBpZiAoIWN1cnZhdHVyZSkge1xuICAgICAgICAgICAgbGluay5fX2N1cnZlID0gbnVsbDsgLy8gU3RyYWlnaHQgbGluZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiZXppZXIgY3VydmUgbGluZSAob25seSBmb3IgbGluZSB0eXBlcylcbiAgICAgICAgICAgIHZhciB2U3RhcnQgPSBuZXcgdGhyZWUkMS5WZWN0b3IzKHN0YXJ0LngsIHN0YXJ0LnkgfHwgMCwgc3RhcnQueiB8fCAwKTtcbiAgICAgICAgICAgIHZhciB2RW5kID0gbmV3IHRocmVlJDEuVmVjdG9yMyhlbmQueCwgZW5kLnkgfHwgMCwgZW5kLnogfHwgMCk7XG4gICAgICAgICAgICB2YXIgbCA9IHZTdGFydC5kaXN0YW5jZVRvKHZFbmQpOyAvLyBsaW5lIGxlbmd0aFxuXG4gICAgICAgICAgICB2YXIgY3VydmU7XG4gICAgICAgICAgICB2YXIgY3VydmVSb3RhdGlvbiA9IGxpbmtDdXJ2ZVJvdGF0aW9uQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGR4ID0gZW5kLnggLSBzdGFydC54O1xuICAgICAgICAgICAgICB2YXIgZHkgPSBlbmQueSAtIHN0YXJ0LnkgfHwgMDtcbiAgICAgICAgICAgICAgdmFyIHZMaW5lID0gbmV3IHRocmVlJDEuVmVjdG9yMygpLnN1YlZlY3RvcnModkVuZCwgdlN0YXJ0KTtcbiAgICAgICAgICAgICAgdmFyIGNwID0gdkxpbmUuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihjdXJ2YXR1cmUpLmNyb3NzKGR4ICE9PSAwIHx8IGR5ICE9PSAwID8gbmV3IHRocmVlJDEuVmVjdG9yMygwLCAwLCAxKSA6IG5ldyB0aHJlZSQxLlZlY3RvcjMoMCwgMSwgMCkpIC8vIGF2b2lkIGNyb3NzLXByb2R1Y3Qgb2YgcGFyYWxsZWwgdmVjdG9ycyAocHJlZmVyIFosIGZhbGxiYWNrIHRvIFkpXG4gICAgICAgICAgICAgIC5hcHBseUF4aXNBbmdsZSh2TGluZS5ub3JtYWxpemUoKSwgY3VydmVSb3RhdGlvbikgLy8gcm90YXRlIGFsb25nIGxpbmUgYXhpcyBhY2NvcmRpbmcgdG8gbGlua0N1cnZlUm90YXRpb25cbiAgICAgICAgICAgICAgLmFkZChuZXcgdGhyZWUkMS5WZWN0b3IzKCkuYWRkVmVjdG9ycyh2U3RhcnQsIHZFbmQpLmRpdmlkZVNjYWxhcigyKSk7XG4gICAgICAgICAgICAgIGN1cnZlID0gbmV3IHRocmVlJDEuUXVhZHJhdGljQmV6aWVyQ3VydmUzKHZTdGFydCwgY3AsIHZFbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gU2FtZSBwb2ludCwgZHJhdyBhIGxvb3BcbiAgICAgICAgICAgICAgdmFyIGQgPSBjdXJ2YXR1cmUgKiA3MDtcbiAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gLWN1cnZlUm90YXRpb247IC8vIFJvdGF0ZSBjbG9ja3dpc2UgKGZyb20gWiBhbmdsZSBwZXJzcGVjdGl2ZSlcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSArIE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICBjdXJ2ZSA9IG5ldyB0aHJlZSQxLkN1YmljQmV6aWVyQ3VydmUzKHZTdGFydCwgbmV3IHRocmVlJDEuVmVjdG9yMyhkICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIGQgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSwgMCkuYWRkKHZTdGFydCksIG5ldyB0aHJlZSQxLlZlY3RvcjMoZCAqIE1hdGguY29zKGVuZEFuZ2xlKSwgZCAqIE1hdGguc2luKGVuZEFuZ2xlKSwgMCkuYWRkKHZTdGFydCksIHZFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluay5fX2N1cnZlID0gY3VydmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVBcnJvd3MoKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBsaW5rIGFycm93IHBvc2l0aW9uXG4gICAgICAgIHZhciBhcnJvd1JlbFBvc0FjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcyk7XG4gICAgICAgIHZhciBhcnJvd0xlbmd0aEFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCk7XG4gICAgICAgIHZhciBub2RlVmFsQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWYWwpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHZhciBhcnJvd09iaiA9IGxpbmsuX19hcnJvd09iajtcbiAgICAgICAgICBpZiAoIWFycm93T2JqKSByZXR1cm47XG4gICAgICAgICAgdmFyIHBvcyA9IGlzRDNTaW0gPyBsaW5rIDogc3RhdGUubGF5b3V0LmdldExpbmtQb3NpdGlvbihzdGF0ZS5sYXlvdXQuZ3JhcGguZ2V0TGluayhsaW5rLnNvdXJjZSwgbGluay50YXJnZXQpLmlkKTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3NbaXNEM1NpbSA/ICdzb3VyY2UnIDogJ2Zyb20nXTtcbiAgICAgICAgICB2YXIgZW5kID0gcG9zW2lzRDNTaW0gPyAndGFyZ2V0JyA6ICd0byddO1xuICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgIHZhciBzdGFydFIgPSBNYXRoLmNicnQoTWF0aC5tYXgoMCwgbm9kZVZhbEFjY2Vzc29yKHN0YXJ0KSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgZW5kUiA9IE1hdGguY2JydChNYXRoLm1heCgwLCBub2RlVmFsQWNjZXNzb3IoZW5kKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgYXJyb3dMZW5ndGggPSBhcnJvd0xlbmd0aEFjY2Vzc29yKGxpbmspO1xuICAgICAgICAgIHZhciBhcnJvd1JlbFBvcyA9IGFycm93UmVsUG9zQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgdmFyIGdldFBvc0Fsb25nTGluZSA9IGxpbmsuX19jdXJ2ZSA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGluay5fX2N1cnZlLmdldFBvaW50KHQpO1xuICAgICAgICAgIH0gLy8gaW50ZXJwb2xhdGUgYWxvbmcgYmV6aWVyIGN1cnZlXG4gICAgICAgICAgOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZTogaW50ZXJwb2xhdGUgbGluZWFybHlcbiAgICAgICAgICAgIHZhciBpcGx0ID0gZnVuY3Rpb24gaXBsdChkaW0sIHN0YXJ0LCBlbmQsIHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0W2RpbV0gKyAoZW5kW2RpbV0gLSBzdGFydFtkaW1dKSAqIHQgfHwgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiBpcGx0KCd4Jywgc3RhcnQsIGVuZCwgdCksXG4gICAgICAgICAgICAgIHk6IGlwbHQoJ3knLCBzdGFydCwgZW5kLCB0KSxcbiAgICAgICAgICAgICAgejogaXBsdCgneicsIHN0YXJ0LCBlbmQsIHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGxpbmVMZW4gPSBsaW5rLl9fY3VydmUgPyBsaW5rLl9fY3VydmUuZ2V0TGVuZ3RoKCkgOiBNYXRoLnNxcnQoWyd4JywgJ3knLCAneiddLm1hcChmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coKGVuZFtkaW1dIHx8IDApIC0gKHN0YXJ0W2RpbV0gfHwgMCksIDIpO1xuICAgICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgdjtcbiAgICAgICAgICB9LCAwKSk7XG4gICAgICAgICAgdmFyIHBvc0Fsb25nTGluZSA9IHN0YXJ0UiArIGFycm93TGVuZ3RoICsgKGxpbmVMZW4gLSBzdGFydFIgLSBlbmRSIC0gYXJyb3dMZW5ndGgpICogYXJyb3dSZWxQb3M7XG4gICAgICAgICAgdmFyIGFycm93SGVhZCA9IGdldFBvc0Fsb25nTGluZShwb3NBbG9uZ0xpbmUgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsID0gZ2V0UG9zQWxvbmdMaW5lKChwb3NBbG9uZ0xpbmUgLSBhcnJvd0xlbmd0aCkgLyBsaW5lTGVuKTtcbiAgICAgICAgICBbJ3gnLCAneScsICd6J10uZm9yRWFjaChmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyb3dPYmoucG9zaXRpb25bZGltXSA9IGFycm93VGFpbFtkaW1dO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBoZWFkVmVjID0gX2NvbnN0cnVjdCh0aHJlZSQxLlZlY3RvcjMsIF90b0NvbnN1bWFibGVBcnJheShbJ3gnLCAneScsICd6J10ubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyb3dIZWFkW2NdO1xuICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgYXJyb3dPYmoucGFyZW50LmxvY2FsVG9Xb3JsZChoZWFkVmVjKTsgLy8gbG9va0F0IHJlcXVpcmVzIHdvcmxkIGNvb3Jkc1xuICAgICAgICAgIGFycm93T2JqLmxvb2tBdChoZWFkVmVjKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVQaG90b25zKCkge1xuICAgICAgICAvLyB1cGRhdGUgbGluayBwYXJ0aWNsZSBwb3NpdGlvbnNcbiAgICAgICAgdmFyIHBhcnRpY2xlU3BlZWRBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCk7XG4gICAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgdmFyIGN5Y2xlUGhvdG9ucyA9IGxpbmsuX19waG90b25zT2JqICYmIGxpbmsuX19waG90b25zT2JqLmNoaWxkcmVuO1xuICAgICAgICAgIHZhciBzaW5nbGVIb3BQaG90b25zID0gbGluay5fX3NpbmdsZUhvcFBob3RvbnNPYmogJiYgbGluay5fX3NpbmdsZUhvcFBob3RvbnNPYmouY2hpbGRyZW47XG4gICAgICAgICAgaWYgKCghc2luZ2xlSG9wUGhvdG9ucyB8fCAhc2luZ2xlSG9wUGhvdG9ucy5sZW5ndGgpICYmICghY3ljbGVQaG90b25zIHx8ICFjeWNsZVBob3RvbnMubGVuZ3RoKSkgcmV0dXJuO1xuICAgICAgICAgIHZhciBwb3MgPSBpc0QzU2ltID8gbGluayA6IHN0YXRlLmxheW91dC5nZXRMaW5rUG9zaXRpb24oc3RhdGUubGF5b3V0LmdyYXBoLmdldExpbmsobGluay5zb3VyY2UsIGxpbmsudGFyZ2V0KS5pZCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcG9zW2lzRDNTaW0gPyAnc291cmNlJyA6ICdmcm9tJ107XG4gICAgICAgICAgdmFyIGVuZCA9IHBvc1tpc0QzU2ltID8gJ3RhcmdldCcgOiAndG8nXTtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgcGFydGljbGVTcGVlZCA9IHBhcnRpY2xlU3BlZWRBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICB2YXIgZ2V0UGhvdG9uUG9zID0gbGluay5fX2N1cnZlID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rLl9fY3VydmUuZ2V0UG9pbnQodCk7XG4gICAgICAgICAgfSAvLyBpbnRlcnBvbGF0ZSBhbG9uZyBiZXppZXIgY3VydmVcbiAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lOiBpbnRlcnBvbGF0ZSBsaW5lYXJseVxuICAgICAgICAgICAgdmFyIGlwbHQgPSBmdW5jdGlvbiBpcGx0KGRpbSwgc3RhcnQsIGVuZCwgdCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RhcnRbZGltXSArIChlbmRbZGltXSAtIHN0YXJ0W2RpbV0pICogdCB8fCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IGlwbHQoJ3gnLCBzdGFydCwgZW5kLCB0KSxcbiAgICAgICAgICAgICAgeTogaXBsdCgneScsIHN0YXJ0LCBlbmQsIHQpLFxuICAgICAgICAgICAgICB6OiBpcGx0KCd6Jywgc3RhcnQsIGVuZCwgdClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcGhvdG9ucyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY3ljbGVQaG90b25zIHx8IFtdKSwgX3RvQ29uc3VtYWJsZUFycmF5KHNpbmdsZUhvcFBob3RvbnMgfHwgW10pKTtcbiAgICAgICAgICBwaG90b25zLmZvckVhY2goZnVuY3Rpb24gKHBob3RvbiwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgc2luZ2xlSG9wID0gcGhvdG9uLnBhcmVudC5fX2xpbmtUaHJlZU9ialR5cGUgPT09ICdzaW5nbGVIb3BQaG90b25zJztcbiAgICAgICAgICAgIGlmICghcGhvdG9uLmhhc093blByb3BlcnR5KCdfX3Byb2dyZXNzUmF0aW8nKSkge1xuICAgICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvID0gc2luZ2xlSG9wID8gMCA6IGlkeCAvIGN5Y2xlUGhvdG9ucy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvICs9IHBhcnRpY2xlU3BlZWQ7XG4gICAgICAgICAgICBpZiAocGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA+PSAxKSB7XG4gICAgICAgICAgICAgIGlmICghc2luZ2xlSG9wKSB7XG4gICAgICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA9IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gJSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwYXJ0aWNsZVxuICAgICAgICAgICAgICAgIHBob3Rvbi5wYXJlbnQucmVtb3ZlKHBob3Rvbik7XG4gICAgICAgICAgICAgICAgZW1wdHlPYmplY3QocGhvdG9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwaG90b25Qb3NSYXRpbyA9IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW87XG4gICAgICAgICAgICB2YXIgcG9zID0gZ2V0UGhvdG9uUG9zKHBob3RvblBvc1JhdGlvKTtcbiAgICAgICAgICAgIFsneCcsICd5JywgJ3onXS5mb3JFYWNoKGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBob3Rvbi5wb3NpdGlvbltkaW1dID0gcG9zW2RpbV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0UGFydGljbGU6IGZ1bmN0aW9uIGVtaXRQYXJ0aWNsZShzdGF0ZSwgbGluaykge1xuICAgICAgaWYgKGxpbmsgJiYgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmluY2x1ZGVzKGxpbmspKSB7XG4gICAgICAgIGlmICghbGluay5fX3NpbmdsZUhvcFBob3RvbnNPYmopIHtcbiAgICAgICAgICB2YXIgb2JqID0gbmV3IHRocmVlJDEuR3JvdXAoKTtcbiAgICAgICAgICBvYmouX19saW5rVGhyZWVPYmpUeXBlID0gJ3NpbmdsZUhvcFBob3RvbnMnO1xuICAgICAgICAgIGxpbmsuX19zaW5nbGVIb3BQaG90b25zT2JqID0gb2JqO1xuICAgICAgICAgIHN0YXRlLmdyYXBoU2NlbmUuYWRkKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpY2xlV2lkdGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aCk7XG4gICAgICAgIHZhciBwaG90b25SID0gTWF0aC5jZWlsKHBhcnRpY2xlV2lkdGhBY2Nlc3NvcihsaW5rKSAqIDEwKSAvIDEwIC8gMjtcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVSZXNvbHV0aW9uO1xuICAgICAgICB2YXIgcGFydGljbGVHZW9tZXRyeSA9IG5ldyB0aHJlZSQxLlNwaGVyZUdlb21ldHJ5KHBob3RvblIsIG51bVNlZ21lbnRzLCBudW1TZWdtZW50cyk7XG4gICAgICAgIHZhciBsaW5rQ29sb3JBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0NvbG9yKTtcbiAgICAgICAgdmFyIHBhcnRpY2xlQ29sb3JBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcik7XG4gICAgICAgIHZhciBwaG90b25Db2xvciA9IHBhcnRpY2xlQ29sb3JBY2Nlc3NvcihsaW5rKSB8fCBsaW5rQ29sb3JBY2Nlc3NvcihsaW5rKSB8fCAnI2YwZjBmMCc7XG4gICAgICAgIHZhciBtYXRlcmlhbENvbG9yID0gbmV3IHRocmVlJDEuQ29sb3IoY29sb3JTdHIySGV4KHBob3RvbkNvbG9yKSk7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gc3RhdGUubGlua09wYWNpdHkgKiAzO1xuICAgICAgICB2YXIgcGFydGljbGVNYXRlcmlhbCA9IG5ldyB0aHJlZSQxLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgIGNvbG9yOiBtYXRlcmlhbENvbG9yLFxuICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGEgc2luZ2xlIGhvcCBwYXJ0aWNsZVxuICAgICAgICBsaW5rLl9fc2luZ2xlSG9wUGhvdG9uc09iai5hZGQobmV3IHRocmVlJDEuTWVzaChwYXJ0aWNsZUdlb21ldHJ5LCBwYXJ0aWNsZU1hdGVyaWFsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldEdyYXBoQmJveDogZnVuY3Rpb24gZ2V0R3JhcGhCYm94KHN0YXRlKSB7XG4gICAgICB2YXIgbm9kZUZpbHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBpZiAoIXN0YXRlLmluaXRpYWxpc2VkKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgY29sbGVjdCBhbGwgbmVzdGVkIGdlb21ldHJpZXMgYmJveGVzXG4gICAgICB2YXIgYmJveGVzID0gZnVuY3Rpb24gZ2V0QmJveGVzKG9iaikge1xuICAgICAgICB2YXIgYmJveGVzID0gW107XG4gICAgICAgIGlmIChvYmouZ2VvbWV0cnkpIHtcbiAgICAgICAgICBvYmouZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgdmFyIGJveCA9IG5ldyB0aHJlZSQxLkJveDMoKTtcbiAgICAgICAgICBib3guY29weShvYmouZ2VvbWV0cnkuYm91bmRpbmdCb3gpLmFwcGx5TWF0cml4NChvYmoubWF0cml4V29ybGQpO1xuICAgICAgICAgIGJib3hlcy5wdXNoKGJveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJib3hlcy5jb25jYXQuYXBwbHkoYmJveGVzLCBfdG9Db25zdW1hYmxlQXJyYXkoKG9iai5jaGlsZHJlbiB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gIW9iai5oYXNPd25Qcm9wZXJ0eSgnX19ncmFwaE9ialR5cGUnKSB8fCBvYmouX19ncmFwaE9ialR5cGUgPT09ICdub2RlJyAmJiBub2RlRmlsdGVyKG9iai5fX2RhdGEpO1xuICAgICAgICB9IC8vIGV4Y2x1ZGUgZmlsdGVyZWQgb3V0IG5vZGVzXG4gICAgICAgICkubWFwKGdldEJib3hlcykpKTtcbiAgICAgIH0oc3RhdGUuZ3JhcGhTY2VuZSk7XG4gICAgICBpZiAoIWJib3hlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBleHRyYWN0IGdsb2JhbCB4LHkseiBtaW4vbWF4XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ3gnLCAneScsICd6J10ubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIGMsIFttaW4oYmJveGVzLCBmdW5jdGlvbiAoYmIpIHtcbiAgICAgICAgICByZXR1cm4gYmIubWluW2NdO1xuICAgICAgICB9KSwgbWF4KGJib3hlcywgZnVuY3Rpb24gKGJiKSB7XG4gICAgICAgICAgcmV0dXJuIGJiLm1heFtjXTtcbiAgICAgICAgfSldKTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LFxuICBzdGF0ZUluaXQ6IGZ1bmN0aW9uIHN0YXRlSW5pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZDNGb3JjZUxheW91dDogZm9yY2VTaW11bGF0aW9uKCkuZm9yY2UoJ2xpbmsnLCBmb3JjZUxpbmsoKSkuZm9yY2UoJ2NoYXJnZScsIGZvcmNlTWFueUJvZHkoKSkuZm9yY2UoJ2NlbnRlcicsIGZvcmNlQ2VudGVyKCkpLmZvcmNlKCdkYWdSYWRpYWwnLCBudWxsKS5zdG9wKCksXG4gICAgICBlbmdpbmVSdW5uaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGhyZWVPYmosIHN0YXRlKSB7XG4gICAgLy8gTWFpbiB0aHJlZSBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgIHN0YXRlLmdyYXBoU2NlbmUgPSB0aHJlZU9iajtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoc3RhdGUsIGNoYW5nZWRQcm9wcykge1xuICAgIHZhciBoYXNBbnlQcm9wQ2hhbmdlZCA9IGZ1bmN0aW9uIGhhc0FueVByb3BDaGFuZ2VkKHByb3BMaXN0KSB7XG4gICAgICByZXR1cm4gcHJvcExpc3Quc29tZShmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gY2hhbmdlZFByb3BzLmhhc093blByb3BlcnR5KHApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIHBhdXNlIHNpbXVsYXRpb25cbiAgICBzdGF0ZS5vblVwZGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5ub2RlQXV0b0NvbG9yQnkgIT09IG51bGwgJiYgaGFzQW55UHJvcENoYW5nZWQoWydub2RlQXV0b0NvbG9yQnknLCAnZ3JhcGhEYXRhJywgJ25vZGVDb2xvciddKSkge1xuICAgICAgLy8gQXV0byBhZGQgY29sb3IgdG8gdW5jb2xvcmVkIG5vZGVzXG4gICAgICBhdXRvQ29sb3JPYmplY3RzKHN0YXRlLmdyYXBoRGF0YS5ub2RlcywgYWNjZXNzb3JGbihzdGF0ZS5ub2RlQXV0b0NvbG9yQnkpLCBzdGF0ZS5ub2RlQ29sb3IpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubGlua0F1dG9Db2xvckJ5ICE9PSBudWxsICYmIGhhc0FueVByb3BDaGFuZ2VkKFsnbGlua0F1dG9Db2xvckJ5JywgJ2dyYXBoRGF0YScsICdsaW5rQ29sb3InXSkpIHtcbiAgICAgIC8vIEF1dG8gYWRkIGNvbG9yIHRvIHVuY29sb3JlZCBsaW5rc1xuICAgICAgYXV0b0NvbG9yT2JqZWN0cyhzdGF0ZS5ncmFwaERhdGEubGlua3MsIGFjY2Vzc29yRm4oc3RhdGUubGlua0F1dG9Db2xvckJ5KSwgc3RhdGUubGlua0NvbG9yKTtcbiAgICB9XG5cbiAgICAvLyBEaWdlc3Qgbm9kZXMgV2ViR0wgb2JqZWN0c1xuICAgIGlmIChzdGF0ZS5fZmx1c2hPYmplY3RzIHx8IGhhc0FueVByb3BDaGFuZ2VkKFsnZ3JhcGhEYXRhJywgJ25vZGVUaHJlZU9iamVjdCcsICdub2RlVGhyZWVPYmplY3RFeHRlbmQnLCAnbm9kZVZhbCcsICdub2RlQ29sb3InLCAnbm9kZVZpc2liaWxpdHknLCAnbm9kZVJlbFNpemUnLCAnbm9kZVJlc29sdXRpb24nLCAnbm9kZU9wYWNpdHknXSkpIHtcbiAgICAgIHZhciBjdXN0b21PYmplY3RBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVRocmVlT2JqZWN0KTtcbiAgICAgIHZhciBjdXN0b21PYmplY3RFeHRlbmRBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVRocmVlT2JqZWN0RXh0ZW5kKTtcbiAgICAgIHZhciB2YWxBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICB2YXIgY29sb3JBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZUNvbG9yKTtcbiAgICAgIHZhciB2aXNpYmlsaXR5QWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWaXNpYmlsaXR5KTtcbiAgICAgIHZhciBzcGhlcmVHZW9tZXRyaWVzID0ge307IC8vIGluZGV4ZWQgYnkgbm9kZSB2YWx1ZVxuICAgICAgdmFyIHNwaGVyZU1hdGVyaWFscyA9IHt9OyAvLyBpbmRleGVkIGJ5IGNvbG9yXG5cbiAgICAgIHRocmVlRGlnZXN0KHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIodmlzaWJpbGl0eUFjY2Vzc29yKSwgc3RhdGUuZ3JhcGhTY2VuZSwge1xuICAgICAgICBwdXJnZTogc3RhdGUuX2ZsdXNoT2JqZWN0cyB8fCBoYXNBbnlQcm9wQ2hhbmdlZChbXG4gICAgICAgIC8vIHJlY3JlYXRlIG9iamVjdHMgaWYgYW55IG9mIHRoZXNlIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAnbm9kZVRocmVlT2JqZWN0JywgJ25vZGVUaHJlZU9iamVjdEV4dGVuZCddKSxcbiAgICAgICAgb2JqRmlsdGVyOiBmdW5jdGlvbiBvYmpGaWx0ZXIob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9iai5fX2dyYXBoT2JqVHlwZSA9PT0gJ25vZGUnO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVPYmo6IGZ1bmN0aW9uIGNyZWF0ZU9iaihub2RlKSB7XG4gICAgICAgICAgdmFyIGN1c3RvbU9iaiA9IGN1c3RvbU9iamVjdEFjY2Vzc29yKG5vZGUpO1xuICAgICAgICAgIHZhciBleHRlbmRPYmogPSBjdXN0b21PYmplY3RFeHRlbmRBY2Nlc3Nvcihub2RlKTtcbiAgICAgICAgICBpZiAoY3VzdG9tT2JqICYmIHN0YXRlLm5vZGVUaHJlZU9iamVjdCA9PT0gY3VzdG9tT2JqKSB7XG4gICAgICAgICAgICAvLyBjbG9uZSBvYmplY3QgaWYgaXQncyBhIHNoYXJlZCBvYmplY3QgYW1vbmcgYWxsIG5vZGVzXG4gICAgICAgICAgICBjdXN0b21PYmogPSBjdXN0b21PYmouY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9iajtcbiAgICAgICAgICBpZiAoY3VzdG9tT2JqICYmICFleHRlbmRPYmopIHtcbiAgICAgICAgICAgIG9iaiA9IGN1c3RvbU9iajtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIGRlZmF1bHQgb2JqZWN0IChzcGhlcmUgbWVzaClcbiAgICAgICAgICAgIG9iaiA9IG5ldyB0aHJlZSQxLk1lc2goKTtcbiAgICAgICAgICAgIG9iai5fX2dyYXBoRGVmYXVsdE9iaiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY3VzdG9tT2JqICYmIGV4dGVuZE9iaikge1xuICAgICAgICAgICAgICBvYmouYWRkKGN1c3RvbU9iaik7IC8vIGV4dGVuZCBkZWZhdWx0IHdpdGggY3VzdG9tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5fX2dyYXBoT2JqVHlwZSA9ICdub2RlJzsgLy8gQWRkIG9iamVjdCB0eXBlXG5cbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVPYmo6IGZ1bmN0aW9uIHVwZGF0ZU9iaihvYmosIG5vZGUpIHtcbiAgICAgICAgICBpZiAob2JqLl9fZ3JhcGhEZWZhdWx0T2JqKSB7XG4gICAgICAgICAgICAvLyBieXBhc3MgaW50ZXJuYWwgdXBkYXRlcyBmb3IgY3VzdG9tIG5vZGUgb2JqZWN0c1xuICAgICAgICAgICAgdmFyIHZhbCA9IHZhbEFjY2Vzc29yKG5vZGUpIHx8IDE7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5jYnJ0KHZhbCkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICAgIHZhciBudW1TZWdtZW50cyA9IHN0YXRlLm5vZGVSZXNvbHV0aW9uO1xuICAgICAgICAgICAgaWYgKCFvYmouZ2VvbWV0cnkudHlwZS5tYXRjaCgvXlNwaGVyZShCdWZmZXIpP0dlb21ldHJ5JC8pIHx8IG9iai5nZW9tZXRyeS5wYXJhbWV0ZXJzLnJhZGl1cyAhPT0gcmFkaXVzIHx8IG9iai5nZW9tZXRyeS5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMgIT09IG51bVNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgIGlmICghc3BoZXJlR2VvbWV0cmllcy5oYXNPd25Qcm9wZXJ0eSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgc3BoZXJlR2VvbWV0cmllc1t2YWxdID0gbmV3IHRocmVlJDEuU3BoZXJlR2VvbWV0cnkocmFkaXVzLCBudW1TZWdtZW50cywgbnVtU2VnbWVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9iai5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIG9iai5nZW9tZXRyeSA9IHNwaGVyZUdlb21ldHJpZXNbdmFsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yQWNjZXNzb3Iobm9kZSk7XG4gICAgICAgICAgICB2YXIgbWF0ZXJpYWxDb2xvciA9IG5ldyB0aHJlZSQxLkNvbG9yKGNvbG9yU3RyMkhleChjb2xvciB8fCAnI2ZmZmZhYScpKTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gc3RhdGUubm9kZU9wYWNpdHkgKiBjb2xvckFscGhhKGNvbG9yKTtcbiAgICAgICAgICAgIGlmIChvYmoubWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnIHx8ICFvYmoubWF0ZXJpYWwuY29sb3IuZXF1YWxzKG1hdGVyaWFsQ29sb3IpIHx8IG9iai5tYXRlcmlhbC5vcGFjaXR5ICE9PSBvcGFjaXR5KSB7XG4gICAgICAgICAgICAgIGlmICghc3BoZXJlTWF0ZXJpYWxzLmhhc093blByb3BlcnR5KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIHNwaGVyZU1hdGVyaWFsc1tjb2xvcl0gPSBuZXcgdGhyZWUkMS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBtYXRlcmlhbENvbG9yLFxuICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsID0gc3BoZXJlTWF0ZXJpYWxzW2NvbG9yXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpZ2VzdCBsaW5rcyBXZWJHTCBvYmplY3RzXG4gICAgaWYgKHN0YXRlLl9mbHVzaE9iamVjdHMgfHwgaGFzQW55UHJvcENoYW5nZWQoWydncmFwaERhdGEnLCAnbGlua1RocmVlT2JqZWN0JywgJ2xpbmtUaHJlZU9iamVjdEV4dGVuZCcsICdsaW5rTWF0ZXJpYWwnLCAnbGlua0NvbG9yJywgJ2xpbmtXaWR0aCcsICdsaW5rVmlzaWJpbGl0eScsICdsaW5rUmVzb2x1dGlvbicsICdsaW5rT3BhY2l0eScsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aCcsICdsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbicsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlUmVzb2x1dGlvbiddKSkge1xuICAgICAgdmFyIF9jdXN0b21PYmplY3RBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1RocmVlT2JqZWN0KTtcbiAgICAgIHZhciBfY3VzdG9tT2JqZWN0RXh0ZW5kQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtUaHJlZU9iamVjdEV4dGVuZCk7XG4gICAgICB2YXIgY3VzdG9tTWF0ZXJpYWxBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua01hdGVyaWFsKTtcbiAgICAgIHZhciBfdmlzaWJpbGl0eUFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICB2YXIgX2NvbG9yQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICB2YXIgd2lkdGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1dpZHRoKTtcbiAgICAgIHZhciBjeWxpbmRlckdlb21ldHJpZXMgPSB7fTsgLy8gaW5kZXhlZCBieSBsaW5rIHdpZHRoXG4gICAgICB2YXIgbGFtYmVydExpbmVNYXRlcmlhbHMgPSB7fTsgLy8gZm9yIGN5bGluZGVyIG9iamVjdHMsIGluZGV4ZWQgYnkgbGluayBjb2xvclxuICAgICAgdmFyIGJhc2ljTGluZU1hdGVyaWFscyA9IHt9OyAvLyBmb3IgbGluZSBvYmplY3RzLCBpbmRleGVkIGJ5IGxpbmsgY29sb3JcblxuICAgICAgdmFyIHZpc2libGVMaW5rcyA9IHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoX3Zpc2liaWxpdHlBY2Nlc3Nvcik7XG5cbiAgICAgIC8vIGxpbmVzIGRpZ2VzdCBjeWNsZVxuICAgICAgdGhyZWVEaWdlc3QodmlzaWJsZUxpbmtzLCBzdGF0ZS5ncmFwaFNjZW5lLCB7XG4gICAgICAgIG9iakJpbmRBdHRyOiAnX19saW5lT2JqJyxcbiAgICAgICAgcHVyZ2U6IHN0YXRlLl9mbHVzaE9iamVjdHMgfHwgaGFzQW55UHJvcENoYW5nZWQoW1xuICAgICAgICAvLyByZWNyZWF0ZSBvYmplY3RzIGlmIGFueSBvZiB0aGVzZSBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgJ2xpbmtUaHJlZU9iamVjdCcsICdsaW5rVGhyZWVPYmplY3RFeHRlbmQnLCAnbGlua1dpZHRoJ10pLFxuICAgICAgICBvYmpGaWx0ZXI6IGZ1bmN0aW9uIG9iakZpbHRlcihvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqLl9fZ3JhcGhPYmpUeXBlID09PSAnbGluayc7XG4gICAgICAgIH0sXG4gICAgICAgIGV4aXRPYmo6IGZ1bmN0aW9uIGV4aXRPYmoob2JqKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNpbmdsZSBwaG90b25zXG4gICAgICAgICAgdmFyIHNpbmdsZVBob3RvbnNPYmogPSBvYmouX19kYXRhICYmIG9iai5fX2RhdGEuX19zaW5nbGVIb3BQaG90b25zT2JqO1xuICAgICAgICAgIGlmIChzaW5nbGVQaG90b25zT2JqKSB7XG4gICAgICAgICAgICBzaW5nbGVQaG90b25zT2JqLnBhcmVudC5yZW1vdmUoc2luZ2xlUGhvdG9uc09iaik7XG4gICAgICAgICAgICBlbXB0eU9iamVjdChzaW5nbGVQaG90b25zT2JqKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX19kYXRhLl9fc2luZ2xlSG9wUGhvdG9uc09iajtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZU9iajogZnVuY3Rpb24gY3JlYXRlT2JqKGxpbmspIHtcbiAgICAgICAgICB2YXIgY3VzdG9tT2JqID0gX2N1c3RvbU9iamVjdEFjY2Vzc29yKGxpbmspO1xuICAgICAgICAgIHZhciBleHRlbmRPYmogPSBfY3VzdG9tT2JqZWN0RXh0ZW5kQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgaWYgKGN1c3RvbU9iaiAmJiBzdGF0ZS5saW5rVGhyZWVPYmplY3QgPT09IGN1c3RvbU9iaikge1xuICAgICAgICAgICAgLy8gY2xvbmUgb2JqZWN0IGlmIGl0J3MgYSBzaGFyZWQgb2JqZWN0IGFtb25nIGFsbCBsaW5rc1xuICAgICAgICAgICAgY3VzdG9tT2JqID0gY3VzdG9tT2JqLmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkZWZhdWx0T2JqO1xuICAgICAgICAgIGlmICghY3VzdG9tT2JqIHx8IGV4dGVuZE9iaikge1xuICAgICAgICAgICAgLy8gY29uc3RydWN0IGRlZmF1bHQgbGluZSBvYmpcbiAgICAgICAgICAgIHZhciB1c2VDeWxpbmRlciA9ICEhd2lkdGhBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICAgIGlmICh1c2VDeWxpbmRlcikge1xuICAgICAgICAgICAgICBkZWZhdWx0T2JqID0gbmV3IHRocmVlJDEuTWVzaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHBsYWluIGxpbmUgKGNvbnN0YW50IHdpZHRoKVxuICAgICAgICAgICAgICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IHRocmVlJDEuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgICAgICAgbGluZUdlb21ldHJ5W3NldEF0dHJpYnV0ZUZuXSgncG9zaXRpb24nLCBuZXcgdGhyZWUkMS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSgyICogMyksIDMpKTtcbiAgICAgICAgICAgICAgZGVmYXVsdE9iaiA9IG5ldyB0aHJlZSQxLkxpbmUobGluZUdlb21ldHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9iajtcbiAgICAgICAgICBpZiAoIWN1c3RvbU9iaikge1xuICAgICAgICAgICAgb2JqID0gZGVmYXVsdE9iajtcbiAgICAgICAgICAgIG9iai5fX2dyYXBoRGVmYXVsdE9iaiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZXh0ZW5kT2JqKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gb2JqZWN0XG4gICAgICAgICAgICAgIG9iaiA9IGN1c3RvbU9iajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGV4dGVuZCBkZWZhdWx0IHdpdGggY3VzdG9tIGluIGEgZ3JvdXBcbiAgICAgICAgICAgICAgb2JqID0gbmV3IHRocmVlJDEuR3JvdXAoKTtcbiAgICAgICAgICAgICAgb2JqLl9fZ3JhcGhEZWZhdWx0T2JqID0gdHJ1ZTtcbiAgICAgICAgICAgICAgb2JqLmFkZChkZWZhdWx0T2JqKTtcbiAgICAgICAgICAgICAgb2JqLmFkZChjdXN0b21PYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmoucmVuZGVyT3JkZXIgPSAxMDsgLy8gUHJldmVudCB2aXN1YWwgZ2xpdGNoZXMgb2YgZGFyayBsaW5lcyBvbiB0b3Agb2Ygbm9kZXMgYnkgcmVuZGVyaW5nIHRoZW0gbGFzdFxuXG4gICAgICAgICAgb2JqLl9fZ3JhcGhPYmpUeXBlID0gJ2xpbmsnOyAvLyBBZGQgb2JqZWN0IHR5cGVcblxuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU9iajogZnVuY3Rpb24gdXBkYXRlT2JqKHVwZE9iaiwgbGluaykge1xuICAgICAgICAgIGlmICh1cGRPYmouX19ncmFwaERlZmF1bHRPYmopIHtcbiAgICAgICAgICAgIC8vIGJ5cGFzcyBpbnRlcm5hbCB1cGRhdGVzIGZvciBjdXN0b20gbGluayBvYmplY3RzXG4gICAgICAgICAgICAvLyBzZWxlY3QgZGVmYXVsdCBvYmplY3QgaWYgaXQncyBhbiBleHRlbmRlZCBncm91cFxuICAgICAgICAgICAgdmFyIG9iaiA9IHVwZE9iai5jaGlsZHJlbi5sZW5ndGggPyB1cGRPYmouY2hpbGRyZW5bMF0gOiB1cGRPYmo7XG4gICAgICAgICAgICB2YXIgbGlua1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoQWNjZXNzb3IobGluaykgKiAxMCkgLyAxMDtcbiAgICAgICAgICAgIHZhciB1c2VDeWxpbmRlciA9ICEhbGlua1dpZHRoO1xuICAgICAgICAgICAgaWYgKHVzZUN5bGluZGVyKSB7XG4gICAgICAgICAgICAgIHZhciByID0gbGlua1dpZHRoIC8gMjtcbiAgICAgICAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc3RhdGUubGlua1Jlc29sdXRpb247XG4gICAgICAgICAgICAgIGlmICghb2JqLmdlb21ldHJ5LnR5cGUubWF0Y2goL15DeWxpbmRlcihCdWZmZXIpP0dlb21ldHJ5JC8pIHx8IG9iai5nZW9tZXRyeS5wYXJhbWV0ZXJzLnJhZGl1c1RvcCAhPT0gciB8fCBvYmouZ2VvbWV0cnkucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyAhPT0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN5bGluZGVyR2VvbWV0cmllcy5oYXNPd25Qcm9wZXJ0eShsaW5rV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgdGhyZWUkMS5DeWxpbmRlckdlb21ldHJ5KHIsIHIsIDEsIG51bVNlZ21lbnRzLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICBnZW9tZXRyeVthcHBseU1hdHJpeDRGbl0obmV3IHRocmVlJDEuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbigwLCAxIC8gMiwgMCkpO1xuICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlbYXBwbHlNYXRyaXg0Rm5dKG5ldyB0aHJlZSQxLk1hdHJpeDQoKS5tYWtlUm90YXRpb25YKE1hdGguUEkgLyAyKSk7XG4gICAgICAgICAgICAgICAgICBjeWxpbmRlckdlb21ldHJpZXNbbGlua1dpZHRoXSA9IGdlb21ldHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmouZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9iai5nZW9tZXRyeSA9IGN5bGluZGVyR2VvbWV0cmllc1tsaW5rV2lkdGhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VzdG9tTWF0ZXJpYWwgPSBjdXN0b21NYXRlcmlhbEFjY2Vzc29yKGxpbmspO1xuICAgICAgICAgICAgaWYgKGN1c3RvbU1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgIG9iai5tYXRlcmlhbCA9IGN1c3RvbU1hdGVyaWFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGNvbG9yID0gX2NvbG9yQWNjZXNzb3IobGluayk7XG4gICAgICAgICAgICAgIHZhciBtYXRlcmlhbENvbG9yID0gbmV3IHRocmVlJDEuQ29sb3IoY29sb3JTdHIySGV4KGNvbG9yIHx8ICcjZjBmMGYwJykpO1xuICAgICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHN0YXRlLmxpbmtPcGFjaXR5ICogY29sb3JBbHBoYShjb2xvcik7XG4gICAgICAgICAgICAgIHZhciBtYXRlcmlhbFR5cGUgPSB1c2VDeWxpbmRlciA/ICdNZXNoTGFtYmVydE1hdGVyaWFsJyA6ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG4gICAgICAgICAgICAgIGlmIChvYmoubWF0ZXJpYWwudHlwZSAhPT0gbWF0ZXJpYWxUeXBlIHx8ICFvYmoubWF0ZXJpYWwuY29sb3IuZXF1YWxzKG1hdGVyaWFsQ29sb3IpIHx8IG9iai5tYXRlcmlhbC5vcGFjaXR5ICE9PSBvcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVNYXRlcmlhbHMgPSB1c2VDeWxpbmRlciA/IGxhbWJlcnRMaW5lTWF0ZXJpYWxzIDogYmFzaWNMaW5lTWF0ZXJpYWxzO1xuICAgICAgICAgICAgICAgIGlmICghbGluZU1hdGVyaWFscy5oYXNPd25Qcm9wZXJ0eShjb2xvcikpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmVNYXRlcmlhbHNbY29sb3JdID0gbmV3IHRocmVlJDFbbWF0ZXJpYWxUeXBlXSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtYXRlcmlhbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogb3BhY2l0eSA8IDEsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoV3JpdGU6IG9wYWNpdHkgPj0gMSAvLyBQcmV2ZW50IHRyYW5zcGFyZW5jeSBpc3N1ZXNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmoubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9iai5tYXRlcmlhbCA9IGxpbmVNYXRlcmlhbHNbY29sb3JdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQXJyb3dzIGRpZ2VzdCBjeWNsZVxuICAgICAgaWYgKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoIHx8IGNoYW5nZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgnbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgnKSkge1xuICAgICAgICB2YXIgYXJyb3dMZW5ndGhBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgpO1xuICAgICAgICB2YXIgYXJyb3dDb2xvckFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yKTtcbiAgICAgICAgdGhyZWVEaWdlc3QodmlzaWJsZUxpbmtzLmZpbHRlcihhcnJvd0xlbmd0aEFjY2Vzc29yKSwgc3RhdGUuZ3JhcGhTY2VuZSwge1xuICAgICAgICAgIG9iakJpbmRBdHRyOiAnX19hcnJvd09iaicsXG4gICAgICAgICAgb2JqRmlsdGVyOiBmdW5jdGlvbiBvYmpGaWx0ZXIob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLl9fbGlua1RocmVlT2JqVHlwZSA9PT0gJ2Fycm93JztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyZWF0ZU9iajogZnVuY3Rpb24gY3JlYXRlT2JqKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IG5ldyB0aHJlZSQxLk1lc2godW5kZWZpbmVkLCBuZXcgdGhyZWUkMS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG9iai5fX2xpbmtUaHJlZU9ialR5cGUgPSAnYXJyb3cnOyAvLyBBZGQgb2JqZWN0IHR5cGVcblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwZGF0ZU9iajogZnVuY3Rpb24gdXBkYXRlT2JqKG9iaiwgbGluaykge1xuICAgICAgICAgICAgdmFyIGFycm93TGVuZ3RoID0gYXJyb3dMZW5ndGhBY2Nlc3NvcihsaW5rKTtcbiAgICAgICAgICAgIHZhciBudW1TZWdtZW50cyA9IHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGlmICghb2JqLmdlb21ldHJ5LnR5cGUubWF0Y2goL15Db25lKEJ1ZmZlcik/R2VvbWV0cnkkLykgfHwgb2JqLmdlb21ldHJ5LnBhcmFtZXRlcnMuaGVpZ2h0ICE9PSBhcnJvd0xlbmd0aCB8fCBvYmouZ2VvbWV0cnkucGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyAhPT0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbmVHZW9tZXRyeSA9IG5ldyB0aHJlZSQxLkNvbmVHZW9tZXRyeShhcnJvd0xlbmd0aCAqIDAuMjUsIGFycm93TGVuZ3RoLCBudW1TZWdtZW50cyk7XG4gICAgICAgICAgICAgIC8vIENvcnJlY3Qgb3JpZW50YXRpb25cbiAgICAgICAgICAgICAgY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSgwLCBhcnJvd0xlbmd0aCAvIDIsIDApO1xuICAgICAgICAgICAgICBjb25lR2VvbWV0cnkucm90YXRlWChNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICAgIG9iai5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIG9iai5nZW9tZXRyeSA9IGNvbmVHZW9tZXRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcnJvd0NvbG9yID0gYXJyb3dDb2xvckFjY2Vzc29yKGxpbmspIHx8IF9jb2xvckFjY2Vzc29yKGxpbmspIHx8ICcjZjBmMGYwJztcbiAgICAgICAgICAgIG9iai5tYXRlcmlhbC5jb2xvciA9IG5ldyB0aHJlZSQxLkNvbG9yKGNvbG9yU3RyMkhleChhcnJvd0NvbG9yKSk7XG4gICAgICAgICAgICBvYmoubWF0ZXJpYWwub3BhY2l0eSA9IHN0YXRlLmxpbmtPcGFjaXR5ICogMyAqIGNvbG9yQWxwaGEoYXJyb3dDb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUGhvdG9uIHBhcnRpY2xlcyBkaWdlc3QgY3ljbGVcbiAgICAgIGlmIChzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMgfHwgY2hhbmdlZFByb3BzLmhhc093blByb3BlcnR5KCdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnKSkge1xuICAgICAgICB2YXIgcGFydGljbGVzQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlcyk7XG4gICAgICAgIHZhciBwYXJ0aWNsZVdpZHRoQWNjZXNzb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGgpO1xuICAgICAgICB2YXIgcGFydGljbGVDb2xvckFjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yKTtcbiAgICAgICAgdmFyIHBhcnRpY2xlTWF0ZXJpYWxzID0ge307IC8vIGluZGV4ZWQgYnkgbGluayBjb2xvclxuICAgICAgICB2YXIgcGFydGljbGVHZW9tZXRyaWVzID0ge307IC8vIGluZGV4ZWQgYnkgcGFydGljbGUgd2lkdGhcblxuICAgICAgICB0aHJlZURpZ2VzdCh2aXNpYmxlTGlua3MuZmlsdGVyKHBhcnRpY2xlc0FjY2Vzc29yKSwgc3RhdGUuZ3JhcGhTY2VuZSwge1xuICAgICAgICAgIG9iakJpbmRBdHRyOiAnX19waG90b25zT2JqJyxcbiAgICAgICAgICBvYmpGaWx0ZXI6IGZ1bmN0aW9uIG9iakZpbHRlcihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouX19saW5rVGhyZWVPYmpUeXBlID09PSAncGhvdG9ucyc7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcmVhdGVPYmo6IGZ1bmN0aW9uIGNyZWF0ZU9iaigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBuZXcgdGhyZWUkMS5Hcm91cCgpO1xuICAgICAgICAgICAgb2JqLl9fbGlua1RocmVlT2JqVHlwZSA9ICdwaG90b25zJzsgLy8gQWRkIG9iamVjdCB0eXBlXG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cGRhdGVPYmo6IGZ1bmN0aW9uIHVwZGF0ZU9iaihvYmosIGxpbmspIHtcbiAgICAgICAgICAgIHZhciBudW1QaG90b25zID0gTWF0aC5yb3VuZChNYXRoLmFicyhwYXJ0aWNsZXNBY2Nlc3NvcihsaW5rKSkpO1xuICAgICAgICAgICAgdmFyIGN1clBob3RvbiA9ICEhb2JqLmNoaWxkcmVuLmxlbmd0aCAmJiBvYmouY2hpbGRyZW5bMF07XG4gICAgICAgICAgICB2YXIgcGhvdG9uUiA9IE1hdGguY2VpbChwYXJ0aWNsZVdpZHRoQWNjZXNzb3IobGluaykgKiAxMCkgLyAxMCAvIDI7XG4gICAgICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVJlc29sdXRpb247XG4gICAgICAgICAgICB2YXIgcGFydGljbGVHZW9tZXRyeTtcbiAgICAgICAgICAgIGlmIChjdXJQaG90b24gJiYgY3VyUGhvdG9uLmdlb21ldHJ5LnBhcmFtZXRlcnMucmFkaXVzID09PSBwaG90b25SICYmIGN1clBob3Rvbi5nZW9tZXRyeS5wYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMgPT09IG51bVNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgIHBhcnRpY2xlR2VvbWV0cnkgPSBjdXJQaG90b24uZ2VvbWV0cnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXBhcnRpY2xlR2VvbWV0cmllcy5oYXNPd25Qcm9wZXJ0eShwaG90b25SKSkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlR2VvbWV0cmllc1twaG90b25SXSA9IG5ldyB0aHJlZSQxLlNwaGVyZUdlb21ldHJ5KHBob3RvblIsIG51bVNlZ21lbnRzLCBudW1TZWdtZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFydGljbGVHZW9tZXRyeSA9IHBhcnRpY2xlR2VvbWV0cmllc1twaG90b25SXTtcbiAgICAgICAgICAgICAgY3VyUGhvdG9uICYmIGN1clBob3Rvbi5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGhvdG9uQ29sb3IgPSBwYXJ0aWNsZUNvbG9yQWNjZXNzb3IobGluaykgfHwgX2NvbG9yQWNjZXNzb3IobGluaykgfHwgJyNmMGYwZjAnO1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsQ29sb3IgPSBuZXcgdGhyZWUkMS5Db2xvcihjb2xvclN0cjJIZXgocGhvdG9uQ29sb3IpKTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gc3RhdGUubGlua09wYWNpdHkgKiAzO1xuICAgICAgICAgICAgdmFyIHBhcnRpY2xlTWF0ZXJpYWw7XG4gICAgICAgICAgICBpZiAoY3VyUGhvdG9uICYmIGN1clBob3Rvbi5tYXRlcmlhbC5jb2xvci5lcXVhbHMobWF0ZXJpYWxDb2xvcikgJiYgY3VyUGhvdG9uLm1hdGVyaWFsLm9wYWNpdHkgPT09IG9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgcGFydGljbGVNYXRlcmlhbCA9IGN1clBob3Rvbi5tYXRlcmlhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghcGFydGljbGVNYXRlcmlhbHMuaGFzT3duUHJvcGVydHkocGhvdG9uQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGVNYXRlcmlhbHNbcGhvdG9uQ29sb3JdID0gbmV3IHRocmVlJDEuTWVzaExhbWJlcnRNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogbWF0ZXJpYWxDb2xvcixcbiAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnRpY2xlTWF0ZXJpYWwgPSBwYXJ0aWNsZU1hdGVyaWFsc1twaG90b25Db2xvcl07XG4gICAgICAgICAgICAgIGN1clBob3RvbiAmJiBjdXJQaG90b24ubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkaWdlc3QgY3ljbGUgZm9yIGVhY2ggcGhvdG9uXG4gICAgICAgICAgICB0aHJlZURpZ2VzdChfdG9Db25zdW1hYmxlQXJyYXkobmV3IEFycmF5KG51bVBob3RvbnMpKS5tYXAoZnVuY3Rpb24gKF8sIGlkeCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkeDogaWR4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSwgb2JqLCB7XG4gICAgICAgICAgICAgIGlkQWNjZXNzb3I6IGZ1bmN0aW9uIGlkQWNjZXNzb3IoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmlkeDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY3JlYXRlT2JqOiBmdW5jdGlvbiBjcmVhdGVPYmooKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aHJlZSQxLk1lc2gocGFydGljbGVHZW9tZXRyeSwgcGFydGljbGVNYXRlcmlhbCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHVwZGF0ZU9iajogZnVuY3Rpb24gdXBkYXRlT2JqKG9iaikge1xuICAgICAgICAgICAgICAgIG9iai5nZW9tZXRyeSA9IHBhcnRpY2xlR2VvbWV0cnk7XG4gICAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsID0gcGFydGljbGVNYXRlcmlhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuX2ZsdXNoT2JqZWN0cyA9IGZhbHNlOyAvLyByZXNldCBvYmplY3RzIHJlZnJlc2ggZmxhZ1xuXG4gICAgLy8gc2ltdWxhdGlvbiBlbmdpbmVcbiAgICBpZiAoaGFzQW55UHJvcENoYW5nZWQoWydncmFwaERhdGEnLCAnbm9kZUlkJywgJ2xpbmtTb3VyY2UnLCAnbGlua1RhcmdldCcsICdudW1EaW1lbnNpb25zJywgJ2ZvcmNlRW5naW5lJywgJ2RhZ01vZGUnLCAnZGFnTm9kZUZpbHRlcicsICdkYWdMZXZlbERpc3RhbmNlJ10pKSB7XG4gICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFBhdXNlIHNpbXVsYXRpb25cblxuICAgICAgLy8gcGFyc2UgbGlua3NcbiAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgIGxpbmsuc291cmNlID0gbGlua1tzdGF0ZS5saW5rU291cmNlXTtcbiAgICAgICAgbGluay50YXJnZXQgPSBsaW5rW3N0YXRlLmxpbmtUYXJnZXRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZlZWQgZGF0YSB0byBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcbiAgICAgIHZhciBpc0QzU2ltID0gc3RhdGUuZm9yY2VFbmdpbmUgIT09ICduZ3JhcGgnO1xuICAgICAgdmFyIGxheW91dDtcbiAgICAgIGlmIChpc0QzU2ltKSB7XG4gICAgICAgIC8vIEQzLWZvcmNlXG4gICAgICAgIChsYXlvdXQgPSBzdGF0ZS5kM0ZvcmNlTGF5b3V0KS5zdG9wKCkuYWxwaGEoMSkgLy8gcmUtaGVhdCB0aGUgc2ltdWxhdGlvblxuICAgICAgICAubnVtRGltZW5zaW9ucyhzdGF0ZS5udW1EaW1lbnNpb25zKS5ub2RlcyhzdGF0ZS5ncmFwaERhdGEubm9kZXMpO1xuXG4gICAgICAgIC8vIGFkZCBsaW5rcyAoaWYgbGluayBmb3JjZSBpcyBzdGlsbCBhY3RpdmUpXG4gICAgICAgIHZhciBsaW5rRm9yY2UgPSBzdGF0ZS5kM0ZvcmNlTGF5b3V0LmZvcmNlKCdsaW5rJyk7XG4gICAgICAgIGlmIChsaW5rRm9yY2UpIHtcbiAgICAgICAgICBsaW5rRm9yY2UuaWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkW3N0YXRlLm5vZGVJZF07XG4gICAgICAgICAgfSkubGlua3Moc3RhdGUuZ3JhcGhEYXRhLmxpbmtzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGRhZyBmb3JjZSBjb25zdHJhaW50c1xuICAgICAgICB2YXIgbm9kZURlcHRocyA9IHN0YXRlLmRhZ01vZGUgJiYgZ2V0RGFnRGVwdGhzKHN0YXRlLmdyYXBoRGF0YSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtzdGF0ZS5ub2RlSWRdO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbm9kZUZpbHRlcjogc3RhdGUuZGFnTm9kZUZpbHRlcixcbiAgICAgICAgICBvbkxvb3BFcnJvcjogc3RhdGUub25EYWdFcnJvciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXhEZXB0aCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QudmFsdWVzKG5vZGVEZXB0aHMgfHwgW10pKSk7XG4gICAgICAgIHZhciBkYWdMZXZlbERpc3RhbmNlID0gc3RhdGUuZGFnTGV2ZWxEaXN0YW5jZSB8fCBzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoIC8gKG1heERlcHRoIHx8IDEpICogREFHX0xFVkVMX05PREVfUkFUSU8gKiAoWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IDAuNyA6IDEpO1xuXG4gICAgICAgIC8vIEZpeCBub2RlcyB0byB4LHkseiBmb3IgZGFnIG1vZGVcbiAgICAgICAgaWYgKHN0YXRlLmRhZ01vZGUpIHtcbiAgICAgICAgICB2YXIgZ2V0RkZuID0gZnVuY3Rpb24gZ2V0RkZuKGZpeCwgaW52ZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFmaXggPyB1bmRlZmluZWQgOiAobm9kZURlcHRoc1tub2RlW3N0YXRlLm5vZGVJZF1dIC0gbWF4RGVwdGggLyAyKSAqIGRhZ0xldmVsRGlzdGFuY2UgKiAoaW52ZXJ0ID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZnhGbiA9IGdldEZGbihbJ2xyJywgJ3JsJ10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEsIHN0YXRlLmRhZ01vZGUgPT09ICdybCcpO1xuICAgICAgICAgIHZhciBmeUZuID0gZ2V0RkZuKFsndGQnLCAnYnUnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSwgc3RhdGUuZGFnTW9kZSA9PT0gJ3RkJyk7XG4gICAgICAgICAgdmFyIGZ6Rm4gPSBnZXRGRm4oWyd6aW4nLCAnem91dCddLmluZGV4T2Yoc3RhdGUuZGFnTW9kZSkgIT09IC0xLCBzdGF0ZS5kYWdNb2RlID09PSAnem91dCcpO1xuICAgICAgICAgIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5maWx0ZXIoc3RhdGUuZGFnTm9kZUZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5meCA9IGZ4Rm4obm9kZSk7XG4gICAgICAgICAgICBub2RlLmZ5ID0gZnlGbihub2RlKTtcbiAgICAgICAgICAgIG5vZGUuZnogPSBmekZuKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHJhZGlhbCBmb3JjZSBmb3IgcmFkaWFsIGRhZ3NcbiAgICAgICAgc3RhdGUuZDNGb3JjZUxheW91dC5mb3JjZSgnZGFnUmFkaWFsJywgWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IGZvcmNlUmFkaWFsKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIG5vZGVEZXB0aCA9IG5vZGVEZXB0aHNbbm9kZVtzdGF0ZS5ub2RlSWRdXSB8fCAtMTtcbiAgICAgICAgICByZXR1cm4gKHN0YXRlLmRhZ01vZGUgPT09ICdyYWRpYWxpbicgPyBtYXhEZXB0aCAtIG5vZGVEZXB0aCA6IG5vZGVEZXB0aCkgKiBkYWdMZXZlbERpc3RhbmNlO1xuICAgICAgICB9KS5zdHJlbmd0aChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5kYWdOb2RlRmlsdGVyKG5vZGUpID8gMSA6IDA7XG4gICAgICAgIH0pIDogbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZ3JhcGhcbiAgICAgICAgdmFyIF9ncmFwaCA9IG5ncmFwaC5ncmFwaCgpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIF9ncmFwaC5hZGROb2RlKG5vZGVbc3RhdGUubm9kZUlkXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIF9ncmFwaC5hZGRMaW5rKGxpbmsuc291cmNlLCBsaW5rLnRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQgPSBuZ3JhcGguZm9yY2VsYXlvdXQoX2dyYXBoLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgZGltZW5zaW9uczogc3RhdGUubnVtRGltZW5zaW9uc1xuICAgICAgICB9LCBzdGF0ZS5uZ3JhcGhQaHlzaWNzKSk7XG4gICAgICAgIGxheW91dC5ncmFwaCA9IF9ncmFwaDsgLy8gQXR0YWNoIGdyYXBoIHJlZmVyZW5jZSB0byBsYXlvdXRcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUud2FybXVwVGlja3MgJiYgIShpc0QzU2ltICYmIHN0YXRlLmQzQWxwaGFNaW4gPiAwICYmIHN0YXRlLmQzRm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pOyBpKyspIHtcbiAgICAgICAgbGF5b3V0W2lzRDNTaW0gPyBcInRpY2tcIiA6IFwic3RlcFwiXSgpO1xuICAgICAgfSAvLyBJbml0aWFsIHRpY2tzIGJlZm9yZSBzdGFydGluZyB0byByZW5kZXJcblxuICAgICAgc3RhdGUubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgIH1cbiAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gdHJ1ZTsgLy8gcmVzdW1lIHNpbXVsYXRpb25cblxuICAgIHN0YXRlLm9uRmluaXNoVXBkYXRlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBmcm9tS2Fwc3VsZSAoa2Fwc3VsZSkge1xuICB2YXIgYmFzZUNsYXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBPYmplY3Q7XG4gIHZhciBpbml0S2Fwc3VsZVdpdGhTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIEZyb21LYXBzdWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYmFzZUNsYXNzKSB7XG4gICAgX2luaGVyaXRzKEZyb21LYXBzdWxlLCBfYmFzZUNsYXNzKTtcbiAgICBmdW5jdGlvbiBGcm9tS2Fwc3VsZSgpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcm9tS2Fwc3VsZSk7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBGcm9tS2Fwc3VsZSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIF90aGlzLl9fa2Fwc3VsZUluc3RhbmNlID0ga2Fwc3VsZSgpLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShpbml0S2Fwc3VsZVdpdGhTZWxmID8gW19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpXSA6IFtdKSwgYXJncykpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZyb21LYXBzdWxlKTtcbiAgfShiYXNlQ2xhc3MpOyAvLyBhdHRhY2gga2Fwc3VsZSBwcm9wcy9tZXRob2RzIHRvIGNsYXNzIHByb3RvdHlwZVxuICBPYmplY3Qua2V5cyhrYXBzdWxlKCkpLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gRnJvbUthcHN1bGUucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJF9fa2Fwc3VsZUluc3RhbjtcbiAgICAgIHZhciByZXR1cm5WYWwgPSAoX3RoaXMkX19rYXBzdWxlSW5zdGFuID0gdGhpcy5fX2thcHN1bGVJbnN0YW5jZSlbbV0uYXBwbHkoX3RoaXMkX19rYXBzdWxlSW5zdGFuLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbCA9PT0gdGhpcy5fX2thcHN1bGVJbnN0YW5jZSA/IHRoaXMgLy8gY2hhaW4gYmFzZWQgb24gdGhpcyBjbGFzcywgbm90IHRoZSBrYXBzdWxlIG9ialxuICAgICAgOiByZXR1cm5WYWw7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBGcm9tS2Fwc3VsZTtcbn1cblxudmFyIHRocmVlID0gd2luZG93LlRIUkVFID8gd2luZG93LlRIUkVFIDoge1xuICBHcm91cDogR3JvdXBcbn07IC8vIFByZWZlciBjb25zdW1wdGlvbiBmcm9tIGdsb2JhbCBUSFJFRSwgaWYgZXhpc3RzXG52YXIgdGhyZWVGb3JjZWdyYXBoID0gZnJvbUthcHN1bGUoRm9yY2VHcmFwaCwgdGhyZWUuR3JvdXAsIHRydWUpO1xuXG5leHBvcnQgeyB0aHJlZUZvcmNlZ3JhcGggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/three-forcegraph@1.41.14_three@0.167.1/node_modules/three-forcegraph/dist/three-forcegraph.mjs\n");

/***/ })

};
;